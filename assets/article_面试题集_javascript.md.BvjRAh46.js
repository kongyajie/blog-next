import{_ as i,c as s,o as l,ae as e}from"./chunks/framework.Dh1jimFm.js";const c=JSON.parse('{"title":"JavaScript面试题","description":"","frontmatter":{},"headers":[],"relativePath":"article/面试题集/javascript.md","filePath":"article/面试题集/javascript.md","lastUpdated":1743859882000}'),t={name:"article/面试题集/javascript.md"};function n(h,a,r,p,k,d){return l(),s("div",null,a[0]||(a[0]=[e(`<h1 id="javascript面试题" tabindex="-1">JavaScript面试题 <a class="header-anchor" href="#javascript面试题" aria-label="Permalink to &quot;JavaScript面试题&quot;">​</a></h1><h2 id="概念题" tabindex="-1">概念题 <a class="header-anchor" href="#概念题" aria-label="Permalink to &quot;概念题&quot;">​</a></h2><h3 id="变量和类型" tabindex="-1">变量和类型 <a class="header-anchor" href="#变量和类型" aria-label="Permalink to &quot;变量和类型&quot;">​</a></h3><ul><li>说说基本数据类型与引用数据类型的区别</li><li>说说js的堆内存与栈内存</li><li>var let const的区别</li><li>null 与 undefined的区别</li><li>typeof instanceof isPrototypeOf Object.toString.call的区别</li><li>深拷贝与浅拷贝，数组深拷贝方法</li><li>== 与 === 的区别，js的类型转换</li><li>如何检测js对象是数组类型</li></ul><h3 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h3><ul><li>new一个对象的内部逻辑，自己实现一个new</li></ul><h3 id="作用域和闭包" tabindex="-1">作用域和闭包 <a class="header-anchor" href="#作用域和闭包" aria-label="Permalink to &quot;作用域和闭包&quot;">​</a></h3><ul><li>说说this的指向，call和apply的作用和区别</li><li>普通函数和箭头函数的区别</li></ul><h3 id="执行机制" tabindex="-1">执行机制 <a class="header-anchor" href="#执行机制" aria-label="Permalink to &quot;执行机制&quot;">​</a></h3><ul><li>Promise用法、自己实现一个</li><li>JS异步解决方案</li><li>宏任务/微任务</li></ul><h3 id="语法和api" tabindex="-1">语法和API <a class="header-anchor" href="#语法和api" aria-label="Permalink to &quot;语法和API&quot;">​</a></h3><ul><li>数组的map、reduce用法</li><li>说说Set、Map、WeakSet、WeakMap</li></ul><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><ul><li><p>编译型语言和解释性语言的区别</p><ul><li>非独立</li><li>效率低</li></ul></li></ul><p>解释性语言和编译性语言的定义： 计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。 翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。</p><p>解释性语言的定义： 解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。 现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。</p><p>编译性语言的定义： 编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。</p><h2 id="编程题" tabindex="-1">编程题 <a class="header-anchor" href="#编程题" aria-label="Permalink to &quot;编程题&quot;">​</a></h2><p>1、如何让： <code>a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  value: [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.value.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,20)]))}const u=i(t,[["render",n]]);export{c as __pageData,u as default};
