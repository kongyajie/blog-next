import{_ as e,c as l,o as t,ae as i}from"./chunks/framework.Dh1jimFm.js";const m=JSON.parse('{"title":"React系列之4-原理","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端框架/react/React系列之4-原理.md","filePath":"article/前端框架/react/React系列之4-原理.md","lastUpdated":1743859882000}'),o={name:"article/前端框架/react/React系列之4-原理.md"};function r(c,a,n,d,s,h){return t(),l("div",null,a[0]||(a[0]=[i('<h1 id="react系列之4-原理" tabindex="-1">React系列之4-原理 <a class="header-anchor" href="#react系列之4-原理" aria-label="Permalink to &quot;React系列之4-原理&quot;">​</a></h1><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><h4 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-label="Permalink to &quot;函数式编程&quot;">​</a></h4><ul><li>纯函数</li><li>不可变值</li></ul><h4 id="jsx的本质-vdom和diff算法" tabindex="-1">JSX的本质&amp;vdom和diff算法 <a class="header-anchor" href="#jsx的本质-vdom和diff算法" aria-label="Permalink to &quot;JSX的本质&amp;vdom和diff算法&quot;">​</a></h4><ul><li>JSX即createElement函数</li><li>执行生成vnode</li><li>patch(elem,vnode) patch(vnode,newVnode)</li></ul><h4 id="合成事件机制" tabindex="-1">合成事件机制 <a class="header-anchor" href="#合成事件机制" aria-label="Permalink to &quot;合成事件机制&quot;">​</a></h4><ul><li>更好的兼容性和跨平台（摆脱DOM的限制，比如在移动端使用时不需重新写一套）</li><li>减少内存消耗，避免频繁解绑</li><li>方便事件的统一管理（如事务机制）</li><li>React17事件绑定到root <ul><li>React16绑定到document</li><li>React17绑定到root</li><li>有利于多个React版本并存，例如微前端</li></ul></li></ul><h4 id="setstate和batchupdate机制" tabindex="-1">setState和batchUpdate机制 <a class="header-anchor" href="#setstate和batchupdate机制" aria-label="Permalink to &quot;setState和batchUpdate机制&quot;">​</a></h4><ul><li>setState 的表现（重要）主流程</li><li>batchUpdate 机制</li><li>transaction（事务）机制</li></ul><h4 id="组件渲染和更新的过程" tabindex="-1">组件渲染和更新的过程 <a class="header-anchor" href="#组件渲染和更新的过程" aria-label="Permalink to &quot;组件渲染和更新的过程&quot;">​</a></h4><ul><li>组件渲染过程 <ul><li>props/state</li><li>render()生成vnode</li><li>patch(elem,vnode)</li></ul></li><li>组件更新过程 <ul><li>setState(newState) --&gt; dirtyComponents(可能有子组件)</li><li>遍历dirtyComponents，根据newState，newProps，通过render()生成newVnode</li><li>patch(vnode,newVnode)</li></ul></li><li>patch被拆分为两个阶段 <ul><li>reconciliation阶段：执行diff算法，纯JS计算</li><li>commit阶段：将diff结果渲染DOM</li></ul></li><li>为什么要拆分：可能会有性能问题 <ul><li>JS是单线程，且和DOM渲染公用一个线程</li><li>当组件足够复杂，组件更新计算和渲染都压力大</li><li>同时再有DOM操作需求（动画、鼠标拖拽等），将卡顿</li></ul></li><li>React fiber <ul><li>将reconciliation阶段进行任务拆分（commit dom渲染无法拆分）</li><li>DOM需要渲染时暂停，空闲时恢复</li><li>window.requestIdleCallback</li></ul></li></ul>',12)]))}const p=e(o,[["render",r]]);export{m as __pageData,p as default};
