import{_ as e,c as o,o as l,ae as t}from"./chunks/framework.Dh1jimFm.js";const n=JSON.parse('{"title":"React系列之6-hooks","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端框架/react/React系列之6-hooks.md","filePath":"article/前端框架/react/React系列之6-hooks.md","lastUpdated":1743859882000}'),s={name:"article/前端框架/react/React系列之6-hooks.md"};function i(r,a,h,u,c,k){return l(),o("div",null,a[0]||(a[0]=[t('<h1 id="react系列之6-hooks" tabindex="-1">React系列之6-hooks <a class="header-anchor" href="#react系列之6-hooks" aria-label="Permalink to &quot;React系列之6-hooks&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>class组件存在问题：</p><ul><li>大型项目很难拆分和重构，很难测试（即class不易拆分）</li><li>相同的业务逻辑，分散到各个方法中，逻辑混乱（ajax请求、绑定/解绑）</li><li>复用逻辑变的复杂，如Mixins、HOC、Render Props</li></ul><p>React组件更易用函数表达：</p><ul><li>React提倡函数式编程，view=fn(props)</li><li>函数更灵活，更易拆分，更易测试</li><li>但函数组件太简单，需要增强能力 — —Hooks</li></ul><p>本章主要内容：</p><ul><li>State Hooks</li><li>Effect Hooks</li><li>其他 Hooks</li><li>自定义 Hooks</li><li>组件逻辑复用（Hooks的意义）</li><li>规范和注意事项</li></ul><h2 id="一、state-hooks" tabindex="-1">一、State Hooks <a class="header-anchor" href="#一、state-hooks" aria-label="Permalink to &quot;一、State Hooks&quot;">​</a></h2><h2 id="二、effect-hooks" tabindex="-1">二、Effect Hooks <a class="header-anchor" href="#二、effect-hooks" aria-label="Permalink to &quot;二、Effect Hooks&quot;">​</a></h2><p>目的：让函数组件模拟生命周期</p><ul><li>默认函数组件没有生命周期</li><li>函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期</li><li>使用 EffectHooks 把生命周期 “钩” 到纯函数中</li></ul><p>useEffect 使用总结</p><ul><li>模拟 componentDidMount - useEffect 依赖 []</li><li>模拟 componentDidUpdate - useEffect 无依赖，或者依赖[a,b]</li><li>模拟 componentWillUmMount - useEffect 中返回一个函数</li></ul><p>useEffect 让纯函数有了副作用</p><ul><li>如设置全局定时任务</li></ul><p>小结</p><ul><li>函数组件更适合React组件，但需要 Hooks 增强功能</li><li>useState 可实现 state 和 setState</li><li>useEffect 可模拟组件主要的生命周期</li></ul><h2 id="三、其他hooks" tabindex="-1">三、其他hooks <a class="header-anchor" href="#三、其他hooks" aria-label="Permalink to &quot;三、其他hooks&quot;">​</a></h2><h3 id="usereducer能代替reduce吗" tabindex="-1">useReducer能代替reduce吗 <a class="header-anchor" href="#usereducer能代替reduce吗" aria-label="Permalink to &quot;useReducer能代替reduce吗&quot;">​</a></h3><ul><li>useReducer 是 useState 的代替方案，用于state复杂变化</li><li>useReducer 是单个组件状态管理，组件通讯还需要props</li><li>redux 是全局的状态管理，多组件共享数据</li></ul><h3 id="usememo使用总结" tabindex="-1">useMemo使用总结 <a class="header-anchor" href="#usememo使用总结" aria-label="Permalink to &quot;useMemo使用总结&quot;">​</a></h3><ul><li>React默认会更新所有子组件</li><li>Class组件使用SCU和PureComponent做优化</li><li>Hooks中使用useMemo，但优化原理是相同的</li></ul><h3 id="usecallback使用总结" tabindex="-1">useCallback使用总结 <a class="header-anchor" href="#usecallback使用总结" aria-label="Permalink to &quot;useCallback使用总结&quot;">​</a></h3><ul><li>useMemo用来缓存数据</li><li>useCallback用来缓存函数</li></ul><h2 id="四、自定义hook" tabindex="-1">四、自定义hook <a class="header-anchor" href="#四、自定义hook" aria-label="Permalink to &quot;四、自定义hook&quot;">​</a></h2><ul><li>本质是一个函数，以use开头</li><li>内部正常使用 useState useEffect 获取其他Hooks</li><li>自定义返回结果，格式不限</li></ul><h3 id="第三方hook" tabindex="-1">第三方hook <a class="header-anchor" href="#第三方hook" aria-label="Permalink to &quot;第三方hook&quot;">​</a></h3><p>todo...</p><h2 id="五、hooks使用规范" tabindex="-1">五、Hooks使用规范 <a class="header-anchor" href="#五、hooks使用规范" aria-label="Permalink to &quot;五、Hooks使用规范&quot;">​</a></h2><ul><li>只能用于React函数组件和自定义Hook中，其他地方不可以</li><li>只能用于顶层代码，不能在循环、判断中使用Hooks</li><li>eslint插件eslint-plugin-react-hooks可以帮到你</li></ul><h3 id="hooks调用顺序必须保持一致" tabindex="-1">Hooks调用顺序必须保持一致 <a class="header-anchor" href="#hooks调用顺序必须保持一致" aria-label="Permalink to &quot;Hooks调用顺序必须保持一致&quot;">​</a></h3><ul><li>无论是render还是re-render，Hooks调用顺序必须保持一致</li><li>如果Hooks出现在循环、判断里，则无法保证顺序一致</li><li>Hooks严重依赖于调用顺序！重要！</li></ul><h3 id="class做组件逻辑复用的问题" tabindex="-1">class做组件逻辑复用的问题 <a class="header-anchor" href="#class做组件逻辑复用的问题" aria-label="Permalink to &quot;class做组件逻辑复用的问题&quot;">​</a></h3><h3 id="hooks做组件逻辑复用的好处" tabindex="-1">Hooks做组件逻辑复用的好处 <a class="header-anchor" href="#hooks做组件逻辑复用的好处" aria-label="Permalink to &quot;Hooks做组件逻辑复用的好处&quot;">​</a></h3><ul><li>完全符合Hook是原有规则，没有其他要求，易于理解记忆</li><li>变量作用域很明确</li><li>不会产生组件嵌套</li></ul><h2 id="六、react-hooks注意事项-哪些坑" tabindex="-1">六、React Hooks注意事项（哪些坑） <a class="header-anchor" href="#六、react-hooks注意事项-哪些坑" aria-label="Permalink to &quot;六、React Hooks注意事项（哪些坑）&quot;">​</a></h2><ul><li>useState初始化state值，只有第一次有效（修改state需要通过setState修改，不能通过props来修改state的值）</li><li>useEffect内部不能修改state（依赖为空[]时不会执行）</li><li>useEffect可能出现死循环（依赖里不能有对象或数组）</li></ul><h2 id="问题解答-自检" tabindex="-1">问题解答（自检） <a class="header-anchor" href="#问题解答-自检" aria-label="Permalink to &quot;问题解答（自检）&quot;">​</a></h2><h4 id="_1、为什么要使用hooks" tabindex="-1">1、为什么要使用Hooks？ <a class="header-anchor" href="#_1、为什么要使用hooks" aria-label="Permalink to &quot;1、为什么要使用Hooks？&quot;">​</a></h4><ul><li>完善函数组件的能力，函数更适合React组件 <ul><li>class组件中，相同的逻辑散落在各处</li><li>DidMount和Didupdate</li></ul></li></ul><h4 id="_2、react-hooks如何模拟组件生命周期" tabindex="-1">2、react Hooks如何模拟组件生命周期？ <a class="header-anchor" href="#_2、react-hooks如何模拟组件生命周期" aria-label="Permalink to &quot;2、react Hooks如何模拟组件生命周期？&quot;">​</a></h4><h4 id="_3、如何自定义hook" tabindex="-1">3、如何自定义Hook <a class="header-anchor" href="#_3、如何自定义hook" aria-label="Permalink to &quot;3、如何自定义Hook&quot;">​</a></h4><h4 id="_4、hooks性能优化" tabindex="-1">4、Hooks性能优化 <a class="header-anchor" href="#_4、hooks性能优化" aria-label="Permalink to &quot;4、Hooks性能优化&quot;">​</a></h4><h4 id="_5、使用hooks遇到哪些坑" tabindex="-1">5、使用Hooks遇到哪些坑 <a class="header-anchor" href="#_5、使用hooks遇到哪些坑" aria-label="Permalink to &quot;5、使用Hooks遇到哪些坑&quot;">​</a></h4><h4 id="_6、hooks相比hoc和props-render有哪些优点" tabindex="-1">6、Hooks相比HOC和props render有哪些优点 <a class="header-anchor" href="#_6、hooks相比hoc和props-render有哪些优点" aria-label="Permalink to &quot;6、Hooks相比HOC和props render有哪些优点&quot;">​</a></h4><h2 id="我的疑问" tabindex="-1">我的疑问 <a class="header-anchor" href="#我的疑问" aria-label="Permalink to &quot;我的疑问&quot;">​</a></h2><h3 id="如何看待hooks的作用-功能增强-和现有的功能如vue-computed对比" tabindex="-1">如何看待hooks的作用？功能增强？和现有的功能如vue computed对比？ <a class="header-anchor" href="#如何看待hooks的作用-功能增强-和现有的功能如vue-computed对比" aria-label="Permalink to &quot;如何看待hooks的作用？功能增强？和现有的功能如vue computed对比？&quot;">​</a></h3><h3 id="不同hooks之间的关系-如-useeffect和userefs" tabindex="-1">不同hooks之间的关系？如 useEffect和useRefs <a class="header-anchor" href="#不同hooks之间的关系-如-useeffect和userefs" aria-label="Permalink to &quot;不同hooks之间的关系？如 useEffect和useRefs&quot;">​</a></h3><h3 id="带hooks的函数组件渲染和更新是怎么个逻辑" tabindex="-1">带hooks的函数组件渲染和更新是怎么个逻辑？ <a class="header-anchor" href="#带hooks的函数组件渲染和更新是怎么个逻辑" aria-label="Permalink to &quot;带hooks的函数组件渲染和更新是怎么个逻辑？&quot;">​</a></h3><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2>',52)]))}const f=e(s,[["render",i]]);export{n as __pageData,f as default};
