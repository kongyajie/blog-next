import{_ as i,c as e,o as a,ae as t}from"./chunks/framework.Dh1jimFm.js";const p=JSON.parse('{"title":"vue","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端框架/vue.md","filePath":"article/前端框架/vue.md","lastUpdated":1743859882000}'),o={name:"article/前端框架/vue.md"};function u(r,l,d,n,s,c){return a(),e("div",null,l[0]||(l[0]=[t('<h1 id="vue" tabindex="-1">vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;vue&quot;">​</a></h1><h3 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h3><ul><li>vue-cli</li><li>基本使用 <ul><li>模板（插值、指令）</li><li>computed和watch</li><li>class和style</li><li>条件</li><li>循环</li><li>事件</li><li>表单</li></ul></li><li>组件 <ul><li>声明周期</li><li>props（类型和默认值）</li><li>v-on和$emit</li><li>自定义事件</li></ul></li><li>高级特性 <ul><li>自定义v-model</li><li>$nextTick</li><li>refs</li><li>slot</li><li>动态组件</li><li>异步组件</li><li>keep-alive</li><li>mixin</li></ul></li></ul><h3 id="周边工具" tabindex="-1">周边工具 <a class="header-anchor" href="#周边工具" aria-label="Permalink to &quot;周边工具&quot;">​</a></h3><ul><li>vuex <ul><li>state</li><li>getters</li><li>action</li><li>mutation</li><li>用于vue(dispatch, commit, mapState, mapGetters, mapActions, mapMutations)</li></ul></li><li>vue-router <ul><li>动态路由</li><li>to和push</li><li>hash和history</li><li>懒加载（配合动态组件）</li></ul></li></ul><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>vue的原理主要包含三个部分：响应式、虚拟dom/diff算法、模板编译，它们三个合在一起，实现了vue的数据驱动视图，大大提升了前端开发效率。</p><p>数据驱动视图，意味着开发者只需关注数据逻辑，而视图的部分vue会自动帮我们进行渲染和更新，而响应式则是其中的第一步； 有了数据响应式，每次数据修改都会进行界面渲染，但dom操作非常耗时，因此react提出了用js来模拟dom结构，计算出最小变更，操作DOM，这样可以大大优化渲染效率。 而虚拟dom的实现中，diff算法又是重中之重。 最后，模板编译是将template</p><ul><li><p>1.组件化和MVVM</p><ul><li>组件化-web1.0就有组件化了，不过传统组件只是静态渲染，更新还要依赖DOM操作</li><li>创新-数据驱动视图-MVVM，不需要手动修改DOM</li><li>MVVM（Model-View-ViewModel）</li></ul></li><li><p>2.响应式原理</p><ul><li>现象：组件data的数据一旦变化，立刻触发视图的更新</li><li>Vue响应式 <ul><li>核心API-Object.defineProperty <ul><li>基本使用</li><li>监听对象，监听数据</li><li>复杂对象，深度监听</li><li>缺点 <ul><li>深度监听，需要递归到底，一次性计算量大</li><li>无法监听新增/删除属性（Vue.set Vue.delete）</li><li>无法原生监听数组，需要特殊处理</li></ul></li></ul></li><li>如何实现响应式，代码演示</li><li>Object.defineProperty缺点（Vue3.0启用Proxy）</li><li>Proxy有兼容性问题，且无法polyfill,比如IE11</li><li>Object.defineProperty()是对对象属性的操作，所以需要对对象进行深度遍历去对属性进行操作。</li><li>vue3.0 用 Proxy 是对对象进行拦截操作，无论是对对象做什么样的操作都会走到 Proxy 的处理逻辑中</li></ul></li></ul></li><li><p>3.vdom和diff算法 vdom起因：</p><ul><li>DOM操作非常耗费性能</li><li>以前用jQuery，可以自行控制DOM操作的时机，手动调整</li><li>Vue和React是数据驱动视图，如何有效控制DOM操作？</li><li>解决方案-vdom-用JS模拟DOM结构，计算出最小的变更，操作DOM 用JS模拟DOM结构（vnode）</li><li>vnode: tag、props、children</li><li>新旧vnode对比，得出最小的更新范围，最后更新DOM 通过 snabbdom 学习vdom</li><li>h函数</li><li>vnode数据结构</li><li>patch函数 diff算法 <ul><li>vdom diff 两棵树做diff</li><li>树diff的时间复杂度O(n^3)-遍历tree1，遍历tree2，排序，1000个节点，要计算一亿次</li><li>优化时间复杂度到O(n) <ul><li>1.只比较同一层级，不跨级比较</li><li>2.tag不相同，则直接删掉重建，不再深度比较</li><li>3.tag和key两者都相同，则认为是相同节点，不再深度比较</li></ul></li><li>sameVnode()</li><li>patchVnode()</li><li>updateChildren（key的重要性） 1、先找到 不需要移动的相同节点，消耗最小 2、再找相同但是需要移动的节点，消耗第二小 3、最后找不到，才会去新建删除节点，保底处理</li><li>为何再v-for中用key <ul><li>diff算法中通过tag和key来判断，是否是sameNode</li><li>减少渲染次数，提升渲染性能</li></ul></li></ul></li></ul></li><li><p>4.模板编译</p></li><li><p>5.组件渲染过程</p></li><li><p>6.前端路由</p></li></ul><h2 id="vue3" tabindex="-1">vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;vue3&quot;">​</a></h2><h3 id="vue3新功能" tabindex="-1">vue3新功能 <a class="header-anchor" href="#vue3新功能" aria-label="Permalink to &quot;vue3新功能&quot;">​</a></h3><ul><li>createApp</li><li>emits属性</li><li>多事件处理</li><li>Fragment</li><li>移除.sync改为v-model参数</li><li>异步组件的引用方式</li><li>移除filter</li><li>Teleport</li><li>Suspense</li><li>Composition API（reactive, ref toRef toRefs readonly computed, watch watchEffect 钩子函数生命周期）</li></ul><h3 id="原理-1" tabindex="-1">原理 <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;原理&quot;">​</a></h3><ul><li>Proxy实现响应式</li><li>编译优化</li><li>Vite-ES5 Module</li></ul><h3 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h3><ul><li>v-show和v-if的区别</li><li>为何v-for中要用key</li><li>描述Vue组件生命周期</li><li>Vue组件如何通讯</li><li>描述组件渲染和更新的过程</li><li>双向数据绑定v-model的实现原理</li></ul>',16)]))}const m=i(o,[["render",u]]);export{p as __pageData,m as default};
