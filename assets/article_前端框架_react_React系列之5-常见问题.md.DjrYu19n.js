import{_ as e,c as l,o as t,ae as i}from"./chunks/framework.Dh1jimFm.js";const m=JSON.parse('{"title":"React系列之5-常见问题","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端框架/react/React系列之5-常见问题.md","filePath":"article/前端框架/react/React系列之5-常见问题.md","lastUpdated":1743859882000}'),r={name:"article/前端框架/react/React系列之5-常见问题.md"};function o(n,a,u,c,h,d){return t(),l("div",null,a[0]||(a[0]=[i('<h1 id="react系列之5-常见问题" tabindex="-1">React系列之5-常见问题 <a class="header-anchor" href="#react系列之5-常见问题" aria-label="Permalink to &quot;React系列之5-常见问题&quot;">​</a></h1><h2 id="jsx本质是什么" tabindex="-1">JSX本质是什么？ <a class="header-anchor" href="#jsx本质是什么" aria-label="Permalink to &quot;JSX本质是什么？&quot;">​</a></h2><ul><li>createElement函数</li><li>执行后返回vnode</li></ul><h2 id="shouldcomponentupdate用途" tabindex="-1">ShouldComponentUpdate用途 <a class="header-anchor" href="#shouldcomponentupdate用途" aria-label="Permalink to &quot;ShouldComponentUpdate用途&quot;">​</a></h2><ul><li>性能优化</li><li>配置“不可变值”一起使用，否则可能出错</li></ul><h2 id="purecomponent-有何区别" tabindex="-1">PureComponent 有何区别 <a class="header-anchor" href="#purecomponent-有何区别" aria-label="Permalink to &quot;PureComponent 有何区别&quot;">​</a></h2><ul><li>实现了浅比较的 SCU</li><li>优化性能</li><li>但要结合不可变值使用</li></ul><h2 id="react事件和dom事件的区别" tabindex="-1">React事件和DOM事件的区别 <a class="header-anchor" href="#react事件和dom事件的区别" aria-label="Permalink to &quot;React事件和DOM事件的区别&quot;">​</a></h2><ul><li>所有事件挂载到 document 上</li><li>event不是原生的，是 <code>SyntheticEvent</code> 合成事件对象</li><li>dispatchEvent</li></ul><h2 id="setstate场景题" tabindex="-1">setState场景题 <a class="header-anchor" href="#setstate场景题" aria-label="Permalink to &quot;setState场景题&quot;">​</a></h2><p>同步/异步/合并修改</p><h2 id="什么是纯函数" tabindex="-1">什么是纯函数 <a class="header-anchor" href="#什么是纯函数" aria-label="Permalink to &quot;什么是纯函数&quot;">​</a></h2><ul><li>返回一个新值，没有副作用</li><li>如 arr1 = arr.slice();</li></ul><h2 id="react组件生命周期" tabindex="-1">React组件生命周期 <a class="header-anchor" href="#react组件生命周期" aria-label="Permalink to &quot;React组件生命周期&quot;">​</a></h2><ul><li>单组件生命周期</li><li>父子组件生命周期</li><li>注意scu</li></ul><h2 id="react发起ajax应该在哪个生命周期" tabindex="-1">React发起ajax应该在哪个生命周期 <a class="header-anchor" href="#react发起ajax应该在哪个生命周期" aria-label="Permalink to &quot;React发起ajax应该在哪个生命周期&quot;">​</a></h2><ul><li>componentDidMount</li></ul><p>理由：</p><ol><li>请求时异步的，使用 <code>componentWillMount</code> 无法避免二次渲染</li><li>react未来版本中 <code>componentWillMount</code> 可能会被调用多次</li></ol><p><a href="https://stackoverflow.com/questions/41612200/in-react-js-should-i-make-my-initial-network-request-in-componentwillmount-or-co/41612993" target="_blank" rel="noreferrer">In React.js should I make my initial network request in componentWillMount or componentDidMount?</a></p><h2 id="组件之间如何通讯" tabindex="-1">组件之间如何通讯？ <a class="header-anchor" href="#组件之间如何通讯" aria-label="Permalink to &quot;组件之间如何通讯？&quot;">​</a></h2><ul><li>父子组件 props</li><li>自定义事件</li><li>Redux 和 Context</li></ul><h2 id="context是什么-如何应用" tabindex="-1">Context是什么，如何应用？ <a class="header-anchor" href="#context是什么-如何应用" aria-label="Permalink to &quot;Context是什么，如何应用？&quot;">​</a></h2><ul><li>父组件向其所有子孙组件传递信息</li><li>如一些简单的公共信息：主题色、语言等</li><li>复杂的公共信息，请用redux</li></ul><h2 id="渲染列表-为何使用key" tabindex="-1">渲染列表，为何使用Key <a class="header-anchor" href="#渲染列表-为何使用key" aria-label="Permalink to &quot;渲染列表，为何使用Key&quot;">​</a></h2><ul><li>同Vue。必须用key，且不能是index和random</li><li>diff算法中通过tag和key来判断，是否是samenode</li><li>减少渲染次数，提高渲染性能</li></ul><h2 id="函数组件和class组件区别" tabindex="-1">函数组件和class组件区别 <a class="header-anchor" href="#函数组件和class组件区别" aria-label="Permalink to &quot;函数组件和class组件区别&quot;">​</a></h2><ul><li>纯函数</li></ul><h2 id="什么是受控组件" tabindex="-1">什么是受控组件？ <a class="header-anchor" href="#什么是受控组件" aria-label="Permalink to &quot;什么是受控组件？&quot;">​</a></h2><ul><li>表单的值受state控制</li><li>需要自行监听onChange，更新state</li><li>对比非受控组件</li></ul><h2 id="何时使用异步组件" tabindex="-1">何时使用异步组件？ <a class="header-anchor" href="#何时使用异步组件" aria-label="Permalink to &quot;何时使用异步组件？&quot;">​</a></h2><ul><li>加载大组件</li><li>路由懒加载</li></ul><h2 id="多个组件有公共逻辑-该如何抽离" tabindex="-1">多个组件有公共逻辑，该如何抽离 <a class="header-anchor" href="#多个组件有公共逻辑-该如何抽离" aria-label="Permalink to &quot;多个组件有公共逻辑，该如何抽离&quot;">​</a></h2><ul><li>高阶组件roc</li><li>Render Props</li><li>mixin（已被react废弃）</li></ul><h2 id="redux单向数据流" tabindex="-1">redux单向数据流 <a class="header-anchor" href="#redux单向数据流" aria-label="Permalink to &quot;redux单向数据流&quot;">​</a></h2><p>画图</p><h2 id="redux如何进行异步请求" tabindex="-1">redux如何进行异步请求 <a class="header-anchor" href="#redux如何进行异步请求" aria-label="Permalink to &quot;redux如何进行异步请求&quot;">​</a></h2><ul><li>使用异步action</li><li>如redux-thunk</li></ul><h2 id="react-router如何配置懒加载" tabindex="-1">react-router如何配置懒加载 <a class="header-anchor" href="#react-router如何配置懒加载" aria-label="Permalink to &quot;react-router如何配置懒加载&quot;">​</a></h2><ul><li>lazy</li><li>import</li><li>Suspense</li></ul><h2 id="react性能优化" tabindex="-1">React性能优化 <a class="header-anchor" href="#react性能优化" aria-label="Permalink to &quot;React性能优化&quot;">​</a></h2><ul><li>渲染列表时加key</li><li>自定义事件、DOM事件及时销毁</li><li>合理使用异步组件</li><li>合理使用scu、pureComponent和memo</li><li>合理使用 Immutable.js</li><li>Webpack优化</li><li>前端通用的性能优化，如图片懒加载</li><li>使用 SSR</li></ul><h2 id="react和vue的区别" tabindex="-1">React和Vue的区别 <a class="header-anchor" href="#react和vue的区别" aria-label="Permalink to &quot;React和Vue的区别&quot;">​</a></h2><ol><li>框架要解决的问题</li></ol><ul><li>都是MVVM框架，都支持数据驱动视图</li><li>都是为了提升前端页面的开发效率</li></ul><ol start="2"><li>原理上</li></ol><ul><li>都使用vdom操作DOM（vue借鉴了react）</li></ul><ol start="3"><li>使用上</li></ol><ul><li>React 使用 JSX 拥抱 JS，Vue 使用模板拥抱 HTML（也支持JSX）；</li><li>React 是函数式编程，Vue 主要是声明式编程</li><li>React 更多需要自力更生（如scu），Vue把想要的都给你（computed、watch），提供了众多语法糖，手动挡 vs 自动挡</li><li>都支持组件化（react class/函数式+hooks组件，vue单文件组件）</li></ul><h2 id="react的样式文件怎么管理" tabindex="-1">React的样式文件怎么管理？ <a class="header-anchor" href="#react的样式文件怎么管理" aria-label="Permalink to &quot;React的样式文件怎么管理？&quot;">​</a></h2><ul><li>Vue组件提供了 <code>.vue单文件组件</code> 的写法，可以在组件内定义和使用局部样式，那React组件内使用的样式如何组织呢？</li></ul><h2 id="为什么事件中的this是undefined" tabindex="-1">为什么事件中的this是undefined？ <a class="header-anchor" href="#为什么事件中的this是undefined" aria-label="Permalink to &quot;为什么事件中的this是undefined？&quot;">​</a></h2>',52)]))}const p=e(r,[["render",o]]);export{m as __pageData,p as default};
