import{_ as s,c as a,o as l,ae as e}from"./chunks/framework.Dh1jimFm.js";const d=JSON.parse('{"title":"week4 - 脚手架命令注册和执行过程开发","description":"","frontmatter":{},"headers":[],"relativePath":"article/架构师课程/week4-笔记.md","filePath":"article/架构师课程/week4-笔记.md","lastUpdated":1743859882000}'),h={name:"article/架构师课程/week4-笔记.md"};function n(t,i,p,r,k,E){return l(),a("div",null,i[0]||(i[0]=[e(`<p>[TOC]</p><h1 id="week4-脚手架命令注册和执行过程开发" tabindex="-1">week4 - 脚手架命令注册和执行过程开发 <a class="header-anchor" href="#week4-脚手架命令注册和执行过程开发" aria-label="Permalink to &quot;week4 - 脚手架命令注册和执行过程开发&quot;">​</a></h1><h2 id="_01-本周导学" tabindex="-1">01-本周导学 <a class="header-anchor" href="#_01-本周导学" aria-label="Permalink to &quot;01-本周导学&quot;">​</a></h2><h3 id="将收获什么" tabindex="-1">将收获什么 <a class="header-anchor" href="#将收获什么" aria-label="Permalink to &quot;将收获什么&quot;">​</a></h3><ul><li>如何设计高性能脚手架</li><li>Node多进程开发</li><li>javascript面向对象的实战技巧</li></ul><h3 id="主要内容" tabindex="-1">主要内容 <a class="header-anchor" href="#主要内容" aria-label="Permalink to &quot;主要内容&quot;">​</a></h3><ul><li>图解<strong>高性能</strong>脚手架架构设计方法</li><li>封装通用的Package和Command类</li><li>基于<strong>缓存+Node多进程</strong>实现动态命令加载和执行</li><li>将业务逻辑和脚手架框架彻底解耦</li></ul><h3 id="附赠内容" tabindex="-1">附赠内容 <a class="header-anchor" href="#附赠内容" aria-label="Permalink to &quot;附赠内容&quot;">​</a></h3><ul><li>Node多进程开发进阶——child_process源码分析 <ul><li>深入Node源码看清spawn/exec/execFile/fork的本质区别，彻底搞懂Node多进程原理</li></ul></li></ul><h3 id="关键词" tabindex="-1">关键词 <a class="header-anchor" href="#关键词" aria-label="Permalink to &quot;关键词&quot;">​</a></h3><ul><li><strong>高性能/可扩展</strong>的脚手架 - <strong>利用缓存提升脚手架性能并解耦业务逻辑</strong></li><li>面向对象 - 利用Class完成javascript面向对象编程</li><li><strong>Node多进程</strong> - 深入Node多进程原理</li></ul><h3 id="学习方法" tabindex="-1">学习方法 <a class="header-anchor" href="#学习方法" aria-label="Permalink to &quot;学习方法&quot;">​</a></h3><ul><li>学以致用：将前两周中学到的知识进行实际应用（commander / Lerna 命令执行原理）</li><li>知识储备：面向对象、ES6新特性Class、shell脚本（macOS）、bat批处理文件等概念需要预先储备</li><li>充分实践：Node多进程是一门较为复杂的技术，需要同学们充分实践和思考</li></ul><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>整体难度处于中上等，如果感觉有难度，一定要多看几遍视频，可以多暂停下来思考，必要的时候可以多画一些流程图、架构图理清思路</li><li>Node多进程高能预警</li></ul><h3 id="本周作业" tabindex="-1">本周作业 <a class="header-anchor" href="#本周作业" aria-label="Permalink to &quot;本周作业&quot;">​</a></h3><ul><li>根据课程讲解内容完成imooc-cli脚手架动态命令执行代码编写</li><li>进阶：尝试分析Node多进程execSync/execFileSync/spawnSync源码</li></ul><h2 id="_02-imooc-cli脚手架命令注册" tabindex="-1">02-imooc-cli脚手架命令注册 <a class="header-anchor" href="#_02-imooc-cli脚手架命令注册" aria-label="Permalink to &quot;02-imooc-cli脚手架命令注册&quot;">​</a></h2><ul><li>脚手架初始化 + 全局参数注册</li><li>脚手架命令注册</li></ul><h2 id="_03-高性能脚手架架构设计和缓存结构设计" tabindex="-1">03-高性能脚手架架构设计和缓存结构设计 <a class="header-anchor" href="#_03-高性能脚手架架构设计和缓存结构设计" aria-label="Permalink to &quot;03-高性能脚手架架构设计和缓存结构设计&quot;">​</a></h2><h3 id="痛点分析" tabindex="-1">痛点分析 <a class="header-anchor" href="#痛点分析" aria-label="Permalink to &quot;痛点分析&quot;">​</a></h3><p>当前脚手架架构如下图：</p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/%E8%84%9A%E6%89%8B%E6%9E%B6-%E5%BD%93%E5%89%8D%E6%9E%B6%E6%9E%84%E7%97%9B%E7%82%B9%E5%88%86%E6%9E%90.jpeg" alt=""></p><p>这样的架构设计已经可以满足一般脚手架需求，但是有以下两个问题：</p><ol><li><strong>cli 安装速度慢</strong>：所有 package 都集成在 cli 里，因此当命令较多时，会减慢 cli 的安装速度</li><li><strong>灵活性差</strong>：init 命令只能使用 @imooc-cli-dev/init 包，对于集团公司而言，每个 bu 的 init 命令可能都各不相同，可能需要实现 init 命令动态化，如： <ul><li>团队 A 使用 @imooc-cli-dev/init 作为初始化模块</li><li>团队 B 使用自己开发的 @imooc-cli-dev/my-init 作为初始化模块</li><li>团队 C 使用自己开发的 @imooc-cli-dev/your-init 作为初始化模块</li></ul></li></ol><p>这时对我们的架构设计就提出挑战，要求我们能够动态加载 init 模块，这将增加架构的复杂度，但大大提升脚手架的可扩展性，将脚手架框架和业务逻辑解耦</p><h3 id="脚手架架构优化" tabindex="-1">脚手架架构优化 <a class="header-anchor" href="#脚手架架构优化" aria-label="Permalink to &quot;脚手架架构优化&quot;">​</a></h3><p>优化结果如下：</p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/%E8%84%9A%E6%89%8B%E6%9E%B6-%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96.jpeg" alt=""></p><h3 id="脚手架命令动态加载功能架构设计" tabindex="-1">脚手架命令动态加载功能架构设计 <a class="header-anchor" href="#脚手架命令动态加载功能架构设计" aria-label="Permalink to &quot;脚手架命令动态加载功能架构设计&quot;">​</a></h3><p>架构设计图如下：</p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/%E8%84%9A%E6%89%8B%E6%9E%B6-%E5%91%BD%E4%BB%A4%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8A%9F%E8%83%BD%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.jpeg" alt=""></p><h3 id="缓存目录" tabindex="-1">缓存目录 <a class="header-anchor" href="#缓存目录" aria-label="Permalink to &quot;缓存目录&quot;">​</a></h3><p>缓存目录位于用户主目录下的 <code>.imooc-cli</code>，如果没有生成该目录时，我们可以手动创建，或者通过如下代码生成：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userHome</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;user-home&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fs-extra&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;path&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cachePath</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userHome, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.imooc-cli&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成缓存目录路径</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fse.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdirpSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(cachePath); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成缓存目录</span></span></code></pre></div><h2 id="_04-通用npm模块类package封装" tabindex="-1">04-通用npm模块类Package封装 <a class="header-anchor" href="#_04-通用npm模块类package封装" aria-label="Permalink to &quot;04-通用npm模块类Package封装&quot;">​</a></h2><ul><li>exists</li><li>install</li><li>update</li></ul><h2 id="_05-预备知识-node多进程入门" tabindex="-1">05-预备知识：Node多进程入门 <a class="header-anchor" href="#_05-预备知识-node多进程入门" aria-label="Permalink to &quot;05-预备知识：Node多进程入门&quot;">​</a></h2><h3 id="官方文档" tabindex="-1">官方文档 <a class="header-anchor" href="#官方文档" aria-label="Permalink to &quot;官方文档&quot;">​</a></h3><p>中文版：<a href="http://nodejs.cn/api/child_process.html" target="_blank" rel="noreferrer">http://nodejs.cn/api/child_process.html</a></p><h3 id="什么是进程" tabindex="-1">什么是进程 <a class="header-anchor" href="#什么是进程" aria-label="Permalink to &quot;什么是进程&quot;">​</a></h3><blockquote><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noreferrer">操作系统</a>结构的基础。</p></blockquote><p>进程的概念主要有两点：</p><ul><li>第一，进程是一个实体。每一个进程都有它自己的地址空间。</li><li>第二，进程是一个“执行中的程序”，存在嵌套关系。</li></ul><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/Node%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B.jpeg" alt=""></p><p>我们在 child_process 中创建的进程就是 Node.js 的子进程</p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/Node%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%AD%90%E8%BF%9B%E7%A8%8B.jpeg" alt=""></p><h3 id="child-process-用法" tabindex="-1">child_process 用法 <a class="header-anchor" href="#child-process-用法" aria-label="Permalink to &quot;child_process 用法&quot;">​</a></h3><p>Node.js基于事件驱动来处理并发，它本身是以单线程模式运行的。Node.js通过<a href="https://link.zhihu.com/?target=https%3A//iojs.org/api/child_process.html" target="_blank" rel="noreferrer">child_process</a>开启子进程执行指定程序。主要包括4个异步进程函数(spawn,exec,execFile,fork)和3个同步进程函数(spawnSync,execFileSync,execSync)。一般我们比较常用的是spawn和exec这两个方法。</p><p><strong>spawn只能运行指定的程序，参数需要在列表中给出，而exec可以直接运行复杂的命令。其中异步进程函数spawn是最基本的创建子进程的函数，其他三个异步函数都是对spawn不同程度的封装。</strong></p><p>spawn适合耗时任务的分布输出，exec则适合输出较少的情况，同步执行</p><h4 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h4><ul><li>exec：执行shell脚本（<strong>一次性输出</strong>）</li><li>execFile：执行shell文件</li><li>fork：使用node执行命令（和 require 效果类似，不同点在于 fork 的文件中 pid 是新的 node 进程 id，和主进程 id 互相独立）</li><li>spawn <code>child_process.spawn(command[, args][, options])</code> 流式处理，持续输出，适合执行<strong>耗时任务</strong>，比如 <code>npm install</code></li></ul><h4 id="同步" tabindex="-1">同步 <a class="header-anchor" href="#同步" aria-label="Permalink to &quot;同步&quot;">​</a></h4><ul><li>execSync</li><li>execFileSync</li><li>spawnSync</li></ul><p>代码演示</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;child_process&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;path&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ls -al&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stdout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stderr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stdout);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stderr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;test.shell&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-al&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-bl&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stdout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">stderr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stdout);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stderr);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let child </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;test.shell&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fork</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;child.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><h2 id="_06-基于node多进程构建高性能脚手架" tabindex="-1">06-基于Node多进程构建高性能脚手架 <a class="header-anchor" href="#_06-基于node多进程构建高性能脚手架" aria-label="Permalink to &quot;06-基于Node多进程构建高性能脚手架&quot;">​</a></h2><h2 id="_07-node进阶-child-process源码分析" tabindex="-1">07-Node进阶：child_process源码分析 <a class="header-anchor" href="#_07-node进阶-child-process源码分析" aria-label="Permalink to &quot;07-Node进阶：child_process源码分析&quot;">​</a></h2><h3 id="疑问和收获" tabindex="-1">疑问和收获 <a class="header-anchor" href="#疑问和收获" aria-label="Permalink to &quot;疑问和收获&quot;">​</a></h3><ul><li>exec 和 execFile 到底有什么区别？</li><li>为什么 exec/execFile/fork 都是通过 spawn 实现的，spawn 的作用到底是什么？</li><li>为什么 spawn 调用后没有回调，而 exec 和 execFile 能够回调？</li><li>为什么 spawn 调用后需要手动调用 child.stdout.on(‘data’, callback)，这里的 child.stdout / child.stderr 到底是什么？</li><li>为什么有 data/error/exit/close 这么多种回调，它们的执行顺序到底是怎样的？</li></ul><h3 id="node-多进程源码总结" tabindex="-1">Node 多进程源码总结 <a class="header-anchor" href="#node-多进程源码总结" aria-label="Permalink to &quot;Node 多进程源码总结&quot;">​</a></h3><ul><li>exec/execFile/spawn/fork的区别 <ul><li>exec：原理是调用 /bin/sh -c 执行我们传入的 shell 脚本，底层调用了 execFile</li><li>execFile：原理是直接执行我们传入的 file 和 args，底层调用 spawn 创建和执行子进程，并建立了回调，一次性将所有的 stdout 和 stderr 结果返回</li><li>spawn：原理是调用了 internal/child_process，实例化了 ChildProcess 子进程对象，再调用 child.spawn 创建子进程并执行命令，底层是调用了 child._handle.spawn 执行 process_wrap 中的 spawn 方法，执行过程是异步的，执行完毕后通过 PIPE 进行单向数据通信，通信结束后会子进程发起 onexit 回调，同时 Socket 会执行 close 回调</li><li>fork：原理是通过 spawn 创建子进程和执行命令，采用 node 执行命令，通过 setupchannel 创建 IPC 用于子进程和父进程之间的双向通信</li></ul></li><li>data/error/exit/close回调的区别 <ul><li>data：主进程读取数据过程中通过 onStreamRead 发起的回调</li><li>error：命令执行失败后发起的回调</li><li>exit：子进程关闭完成后发起的回调</li><li>close：子进程所有 Socket 通信端口全部关闭后发起的回调</li><li>stdout close/stderr close：特定的 PIPE 读取完成后调用 onReadableStreamEnd 关闭 Socket 时发起的回调</li></ul></li></ul><h3 id="exec-源码深入分析" tabindex="-1">exec 源码深入分析 <a class="header-anchor" href="#exec-源码深入分析" aria-label="Permalink to &quot;exec 源码深入分析&quot;">​</a></h3><ul><li>child_process <ul><li>exec</li><li>execFile</li><li>spawn</li></ul></li><li>internal/child_process <ul><li>ChildProcess</li><li>spawn</li></ul></li></ul><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/Node%E5%A4%9A%E8%BF%9B%E7%A8%8B-child_process%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.jpeg" alt=""></p><h3 id="node-多进程回调流程" tabindex="-1">Node 多进程回调流程 <a class="header-anchor" href="#node-多进程回调流程" aria-label="Permalink to &quot;Node 多进程回调流程&quot;">​</a></h3><ul><li>spawn</li><li>Pipe</li><li>onexit</li><li>kill</li><li>Socket</li><li>close</li><li>exit</li></ul><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/Node%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%9B%9E%E8%B0%83%E6%B5%81%E7%A8%8B.jpeg" alt=""></p><h3 id="node-多进程执行阶段总结" tabindex="-1">Node 多进程执行阶段总结 <a class="header-anchor" href="#node-多进程执行阶段总结" aria-label="Permalink to &quot;Node 多进程执行阶段总结&quot;">​</a></h3><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/Node%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93.jpeg" alt=""></p><h3 id="fork-执行流程分析" tabindex="-1">Fork 执行流程分析 <a class="header-anchor" href="#fork-执行流程分析" aria-label="Permalink to &quot;Fork 执行流程分析&quot;">​</a></h3><p>核心区别是创建 IPC Channel 取代 [stdin, stdout, stderr]</p><h3 id="同步方法源码分析" tabindex="-1">同步方法源码分析 <a class="header-anchor" href="#同步方法源码分析" aria-label="Permalink to &quot;同步方法源码分析&quot;">​</a></h3><p>核心是调用 Process.spawnSync</p><h3 id="知识储备" tabindex="-1">知识储备 <a class="header-anchor" href="#知识储备" aria-label="Permalink to &quot;知识储备&quot;">​</a></h3><h4 id="shell的使用" tabindex="-1">shell的使用 <a class="header-anchor" href="#shell的使用" aria-label="Permalink to &quot;shell的使用&quot;">​</a></h4><p>方法一：直接执行shell文件</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/bin/sh</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test.shell</span></span></code></pre></div><p>方法二：直接执行shell语句</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">/bin/sh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ls -al|grep node_modules&quot;</span></span></code></pre></div>`,81)]))}const c=s(h,[["render",n]]);export{d as __pageData,c as default};
