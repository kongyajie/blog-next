import{_ as e,c as t,o as l,ae as s,j as n,t as h}from"./chunks/framework.Dh1jimFm.js";const E=JSON.parse('{"title":"Vue系列之5-常见问题","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端框架/vue/Vue系列之5-常见问题.md","filePath":"article/前端框架/vue/Vue系列之5-常见问题.md","lastUpdated":1743859882000}'),p={name:"article/前端框架/vue/Vue系列之5-常见问题.md"};function r(a,i,o,k,d,u){return l(),t("div",null,[i[0]||(i[0]=s(`<h1 id="vue系列之5-常见问题" tabindex="-1">Vue系列之5-常见问题 <a class="header-anchor" href="#vue系列之5-常见问题" aria-label="Permalink to &quot;Vue系列之5-常见问题&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>本章介绍Vue常见问题</p><h2 id="一、基础使用" tabindex="-1">一、基础使用 <a class="header-anchor" href="#一、基础使用" aria-label="Permalink to &quot;一、基础使用&quot;">​</a></h2><h3 id="computed和watch的区别" tabindex="-1">computed和watch的区别 <a class="header-anchor" href="#computed和watch的区别" aria-label="Permalink to &quot;computed和watch的区别&quot;">​</a></h3><ul><li>computed <ul><li>不支持异步</li><li>多对一</li><li>默认是set函数</li></ul></li><li>watch <ul><li>支持异步</li><li>一对多</li><li>可设置deep和immediate，以及字符串的形式监听&#39;obj.a&#39;</li></ul></li></ul><h3 id="v-if-和-v-show有什么区别" tabindex="-1">v-if 和 v-show有什么区别 <a class="header-anchor" href="#v-if-和-v-show有什么区别" aria-label="Permalink to &quot;v-if 和 v-show有什么区别&quot;">​</a></h3><ul><li>v-if 不会渲染出元素</li><li>v-show 会渲染元素，只是将display设为了none</li><li>visibility:hidden，是隐藏元素，但元素依然占据空间</li><li>opacity:0 是设置透明度，可以看做是障眼法</li></ul><h3 id="v-if-和-v-for-不推荐一起使用" tabindex="-1">v-if 和 v-for 不推荐一起使用？ <a class="header-anchor" href="#v-if-和-v-for-不推荐一起使用" aria-label="Permalink to &quot;v-if 和 v-for 不推荐一起使用？&quot;">​</a></h3><ul><li>因为v-for优先级比v-if要高，而遍历时会重复执行条件判断，影响性能</li><li>解决方案：使用computed筛选</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user in users&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        v-if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user.isActive&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user.id&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {{user.name}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user in activeUsers&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user.id&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {{user.name}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    activeUsers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.users.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> el.isActive);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="二、组件相关" tabindex="-1">二、组件相关 <a class="header-anchor" href="#二、组件相关" aria-label="Permalink to &quot;二、组件相关&quot;">​</a></h2><h3 id="vue生命周期-重点" tabindex="-1">vue生命周期（重点） <a class="header-anchor" href="#vue生命周期-重点" aria-label="Permalink to &quot;vue生命周期（重点）&quot;">​</a></h3><ul><li><strong>beforeCreated</strong> （初始化前）</li><li><strong>created</strong> （vue实例的数据对象data有了）</li><li><strong>beforeMounted</strong> （vue实例的data和$el都初始化了，但未渲染）</li><li><strong>mounted</strong> （vue实例挂载完成，成功渲染）</li><li><strong>beforeUpdated</strong></li><li><strong>updated</strong></li><li><strong>beforeDestoryed</strong> （解除事件监听和dom绑定，但dom结构依然存在）</li><li><strong>destroyed</strong> （All Gone）</li></ul><blockquote><p>1.<strong>创建前/后</strong>： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</p></blockquote><blockquote><p>2.<strong>载入前/后</strong>：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p></blockquote><blockquote><p>3.<strong>更新前/后</strong>：当data变化时，会触发beforeUpdate和updated方法</p></blockquote><blockquote><p>4.<strong>销毁前/后</strong>：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p></blockquote><h3 id="组件间通讯-重点" tabindex="-1">组件间通讯（重点） <a class="header-anchor" href="#组件间通讯-重点" aria-label="Permalink to &quot;组件间通讯（重点）&quot;">​</a></h3><ul><li>父传子：props</li><li>子传父：$emit()</li><li>组件之间：eventBus事件中心、Vuex</li></ul><h3 id="定义组件一定要使用单文件组件吗" tabindex="-1">定义组件一定要使用单文件组件吗？ <a class="header-anchor" href="#定义组件一定要使用单文件组件吗" aria-label="Permalink to &quot;定义组件一定要使用单文件组件吗？&quot;">​</a></h3><blockquote><p>单文件组件为了解决 Vue.component 直接定义组件的种种限制而提出的,因此不是必须的。</p></blockquote><ul><li><strong>全局定义 (Global definitions)</strong> 强制要求每个 component 中的命名不得重复</li><li><strong>字符串模板 (String templates)</strong> 缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \\</li><li><strong>不支持 CSS (No CSS support)</strong> 意味着当 HTML 和 JavaScript 组件化时，CSS 明显被遗漏</li><li><strong>没有构建步骤 (No build step)</strong> 限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug (formerly Jade) 和 Babel</li></ul><p><a href="https://cn.vuejs.org/v2/guide/single-file-components.html#ad" target="_blank" rel="noreferrer">单文件组件</a></p><h3 id="为什么vue组件中的data必须是一个函数" tabindex="-1">为什么vue组件中的data必须是一个函数 <a class="header-anchor" href="#为什么vue组件中的data必须是一个函数" aria-label="Permalink to &quot;为什么vue组件中的data必须是一个函数&quot;">​</a></h3><blockquote><p>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p></blockquote><h2 id="三、高级特性相关" tabindex="-1">三、高级特性相关 <a class="header-anchor" href="#三、高级特性相关" aria-label="Permalink to &quot;三、高级特性相关&quot;">​</a></h2><h3 id="vue如何获取dom" tabindex="-1">vue如何获取dom <a class="header-anchor" href="#vue如何获取dom" aria-label="Permalink to &quot;vue如何获取dom&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$refs.domName</span></span></code></pre></div><h3 id="v-on可以监听多个方法吗" tabindex="-1">v-on可以监听多个方法吗 <a class="header-anchor" href="#v-on可以监听多个方法吗" aria-label="Permalink to &quot;v-on可以监听多个方法吗&quot;">​</a></h3><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;{ input:onInput,focus:onFocus,blur:onBlur, }&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="slot插槽使用场景" tabindex="-1">slot插槽使用场景 <a class="header-anchor" href="#slot插槽使用场景" aria-label="Permalink to &quot;slot插槽使用场景&quot;">​</a></h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p><h3 id="vue初始化白屏问题" tabindex="-1">vue初始化白屏问题 <a class="header-anchor" href="#vue初始化白屏问题" aria-label="Permalink to &quot;vue初始化白屏问题&quot;">​</a></h3>`,36)),n("p",null,"使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于"+h(a.message)+"的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。 首先：在css里加上以下代码",1),i[1]||(i[1]=s(`<div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">v-cloak</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;{display: &#39;block&#39;}&quot;</code></p><h3 id="nexttick是什么-重点" tabindex="-1">$nextTick是什么（重点） <a class="header-anchor" href="#nexttick是什么-重点" aria-label="Permalink to &quot;$nextTick是什么（重点）&quot;">​</a></h3><blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote><p><a href="https://juejin.cn/post/6875492931726376974" target="_blank" rel="noreferrer">Vue的nextTick具体是微任务还是宏任务?</a></p><h3 id="v-model的原理-自定义v-model-重点" tabindex="-1">v-model的原理&amp;自定义v-model（重点） <a class="header-anchor" href="#v-model的原理-自定义v-model-重点" aria-label="Permalink to &quot;v-model的原理&amp;自定义v-model（重点）&quot;">​</a></h3><p>v-model的原理：</p><ol><li>绑定 <code>value</code> 属性</li><li>监听 <code>input</code> 事件，触发时，将 <code>event.target.value</code> 赋值给 <code>value</code></li></ol><p>自定义v-model</p><ol><li>自定义组件需要使用v-model进行双向数据绑定时，如</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">colorPicker</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;colorValue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">colorPicker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="2"><li>需添加 <code>model</code> 选项来指定 <code>prop</code> 和 <code>event</code></li></ol><ul><li><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model" target="_blank" rel="noreferrer">自定义组件的-v-model</a></li></ul><h3 id="sync的作用和原理-重点" tabindex="-1">.sync的作用和原理（重点） <a class="header-anchor" href="#sync的作用和原理-重点" aria-label="Permalink to &quot;.sync的作用和原理（重点）&quot;">​</a></h3><blockquote><p>.sync 用来实现双向数据绑定，但可能会带来维护上的问题，因为子组件可以修改父组件，且在子组件和父组件都没有明显的改动来源。</p></blockquote><p>正常情况下我们组件间通讯通过父组件prop传值和子组件$emit()发送事件来实现：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!--父组件给子组件传入一个函数--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">Footers</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;(res)=&gt; name = res&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">Footers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!--子组件通过调用这个函数来实现修改父组件的状态。--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setName&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1234567</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>.sync则可以这样实现：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!--父组件将name传给子组件并使用.sync修饰符。--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">Footers</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :name.sync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">Footers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!--子组件触发事件--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;update:name&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1234567</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h3 id="vue-mixin-vs-vue-extend-重点" tabindex="-1">Vue.mixin vs Vue.Extend（重点） <a class="header-anchor" href="#vue-mixin-vs-vue-extend-重点" aria-label="Permalink to &quot;Vue.mixin vs Vue.Extend（重点）&quot;">​</a></h3><ul><li><p>mixin用来分发 Vue 组件中的可复用功能，如 <code>methods</code> <code>directives</code> 等，可以是在组件层级使用，或全局使用，全局使用会影响之后创建的vue实例</p></li><li><p>Vue.extend(options)是产生一个继承自Vue类的子类，只会影响这个子类的实例对象，不会对Vue类本身以及Vue类的实例对象产生影响。</p></li><li><p>Vue.component 定义一个全局组件（内部有调用Vue.extend）</p></li><li><p>new Vue() 创建一个vue实例</p></li></ul><p><a href="https://stackoverflow.com/questions/40719200/what-is-vue-extend-for" target="_blank" rel="noreferrer">what-is-vue-extend-for</a></p><h2 id="四、周边工具" tabindex="-1">四、周边工具 <a class="header-anchor" href="#四、周边工具" aria-label="Permalink to &quot;四、周边工具&quot;">​</a></h2><h3 id="vue-cli3脚手架配置-vue-config-js" tabindex="-1">vue-cli3脚手架配置（vue.config.js） <a class="header-anchor" href="#vue-cli3脚手架配置-vue-config-js" aria-label="Permalink to &quot;vue-cli3脚手架配置（vue.config.js）&quot;">​</a></h3><ul><li><strong>publicPath</strong> 部署应用包时的基本 URL</li><li><strong>productionSourceMap</strong> 不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</li><li><strong>assetsDir</strong> 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是&#39;&#39;,</li><li><strong>indexPath</strong> 指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是&#39;index.html&#39;</li><li><strong>lintOnSave</strong> 是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</li><li><strong>css</strong></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">css</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    extract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sourceMap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//效果同上</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    modules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 为所有的 CSS 及其预处理文件开启 CSS Modules。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这个选项不会影响 \`*.vue\` 文件。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span></code></pre></div><ul><li><strong>devServer</strong> 本地开发服务器配置</li><li><strong>pluginOptions</strong> 第三方插件选项</li><li><strong>chainWebpack</strong> 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。</li></ul><h3 id="vuex是什么" tabindex="-1">vuex是什么 <a class="header-anchor" href="#vuex是什么" aria-label="Permalink to &quot;vuex是什么&quot;">​</a></h3><blockquote><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p></blockquote><h3 id="vuex中有几个核心属性-分别是什么" tabindex="-1">vuex中有几个核心属性，分别是什么 <a class="header-anchor" href="#vuex中有几个核心属性-分别是什么" aria-label="Permalink to &quot;vuex中有几个核心属性，分别是什么&quot;">​</a></h3><ul><li><strong>state</strong> 唯一数据源,Vue 实例中的 data 遵循相同的规则</li><li><strong>getters</strong> 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</li><li><strong>mutation</strong> 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li><li><strong>action</strong> Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li><li><strong>module</strong> 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li></ul><h3 id="mutation和action区别" tabindex="-1">mutation和action区别 <a class="header-anchor" href="#mutation和action区别" aria-label="Permalink to &quot;mutation和action区别&quot;">​</a></h3><ul><li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li><li>action 可以包含任意异步操作。mutation只能是同步操作</li><li>提交方式不同</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// action 是用this.store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交</span></span></code></pre></div><ul><li>接收参数不同</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    state,      </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 \`store.state\`，若在模块中则为局部状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootState,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 \`store.state\`，只存在于模块中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    commit,     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 \`store.commit\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dispatch,   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 \`store.dispatch\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    getters,    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 \`store.getters\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rootGetters </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于 \`store.getters\`，只存在于模块中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="vue-router是什么" tabindex="-1">vue-router是什么 <a class="header-anchor" href="#vue-router是什么" aria-label="Permalink to &quot;vue-router是什么&quot;">​</a></h3><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的</li><li>路由配置路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h2 id="五、原理相关" tabindex="-1">五、原理相关 <a class="header-anchor" href="#五、原理相关" aria-label="Permalink to &quot;五、原理相关&quot;">​</a></h2><h3 id="vue-js内部运行机制" tabindex="-1">Vue.js内部运行机制 <a class="header-anchor" href="#vue-js内部运行机制" aria-label="Permalink to &quot;Vue.js内部运行机制&quot;">​</a></h3><h3 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;MVVM&quot;">​</a></h3><blockquote><p><code>MVVM(Model-View-ViewModel)</code> 是一种软件架构模式。来自MVC模式，由微软架构师Ken Cooper和Ted Peters开发，通过利用WPF（微软.NET图形系统）和Silverlight（WPF的互联网应用派生品）的特性来简化用户界面的事件驱动程序设计。微软的WPF和Silverlight架构师之一John Gossman于2005年在他的博客上发表了MVVM。 <code>MVVM也被称为model-view-binder</code></p></blockquote><h3 id="vue-loader是什么" tabindex="-1">vue-loader是什么 <a class="header-anchor" href="#vue-loader是什么" aria-label="Permalink to &quot;vue-loader是什么&quot;">​</a></h3><blockquote><p>vue文件的一个加载器，将template/js/style转换成js模块。</p></blockquote><h3 id="vue的双向绑定原理是什么" tabindex="-1">Vue的双向绑定原理是什么 <a class="header-anchor" href="#vue的双向绑定原理是什么" aria-label="Permalink to &quot;Vue的双向绑定原理是什么&quot;">​</a></h3><blockquote><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p></blockquote><ul><li><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></li><li><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></li><li><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></li><li><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></li></ul><h3 id="object-defineproperty-vs-proxy-重点" tabindex="-1">Object.defineProperty vs Proxy（重点） <a class="header-anchor" href="#object-defineproperty-vs-proxy-重点" aria-label="Permalink to &quot;Object.defineProperty vs Proxy（重点）&quot;">​</a></h3><p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。Avalon.js 为了兼容IE6，使用了 VBScript 来实现响应式。</p><h4 id="_1、object-defineproperty" tabindex="-1">1、Object.defineProperty <a class="header-anchor" href="#_1、object-defineproperty" aria-label="Permalink to &quot;1、Object.defineProperty&quot;">​</a></h4><blockquote><p>Object.defineProperty 本质上是对对象属性的劫持，vue1、vue2采用，支持IE9+</p></blockquote><p><strong>缺点1、无法检测对象属性的添加和移除</strong></p><ul><li>原因：Object.defineProperty api的限制，只能对已知的属性进行绑定，因此直接在对象上添加属性是无法监听到的，需要额外处理；而移除操作在这个api上也是无法知晓的，因此需要额外处理。</li><li>解决方法：vue提供$set、$delete处理</li><li>另外请注意 <code>this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</code> 和 <code>Object.assign(this.someObject, { a: 1, b: 2 })</code> 的区别）</li></ul><p><strong>缺点2、数组API方法监听不到（对数组api方法进行重写）</strong></p><ul><li>原因：Object.defineProperty 监听不到数组的变化</li><li>解决方法：Vue2.0 对数组的<strong>变更方法</strong>进行了重写：<a href="https://segmentfault.com/a/1190000015075679" target="_blank" rel="noreferrer">参考</a><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse() 非变更方法比如 <code>filter()</code> <code>concat()</code> <code>slice</code> 每次都会返回一个新的数组，vue中的vdom会尽量复用，因此也不用担心性能问题</li></ul></li></ul><p><strong>缺点3、需深度遍历对象中的对象属性（会有一些性能消耗）</strong></p><ul><li>原因：Object.defineProperty 是对对象属性的监听，因此需要遍历对象的属性，当嵌套较深时，会有一些性能消耗</li><li>解决方法：Vue3 使用了 proxy 实现</li></ul><h4 id="_2、proxy-vue3-0采用-ie11" tabindex="-1">2、Proxy（vue3.0采用，IE11+） <a class="header-anchor" href="#_2、proxy-vue3-0采用-ie11" aria-label="Permalink to &quot;2、Proxy（vue3.0采用，IE11+）&quot;">​</a></h4><ul><li>相当于在对象外层加拦截</li><li>缺点： <ul><li>不兼容IE11，也没有 polyfill</li></ul></li></ul><h3 id="v-for-key的作用-重点" tabindex="-1">v-for key的作用（重点） <a class="header-anchor" href="#v-for-key的作用-重点" aria-label="Permalink to &quot;v-for key的作用（重点）&quot;">​</a></h3><blockquote><p>在diff算法中的 updateChildren 时，尽可能的复用key相同的节点，尽量使用移动而不是更新dom的操作</p><p>在vdom diff算法中，若 tag 和 key 都相同，则认为是同一节点，因此在v-for中添加key，可复用节点，进而提高性能</p></blockquote><h3 id="vue-js的template编译过程-重点" tabindex="-1">vue.js的template编译过程（重点） <a class="header-anchor" href="#vue-js的template编译过程-重点" aria-label="Permalink to &quot;vue.js的template编译过程（重点）&quot;">​</a></h3><blockquote><p><strong>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）</strong>，详细步骤如下：</p><p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option</p><p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p></blockquote><h3 id="vue源码整体运行流程-逻辑-重点-待完善" tabindex="-1">vue源码整体运行流程/逻辑？（重点，待完善） <a class="header-anchor" href="#vue源码整体运行流程-逻辑-重点-待完善" aria-label="Permalink to &quot;vue源码整体运行流程/逻辑？（重点，待完善）&quot;">​</a></h3><ul><li><p>1、new Vue(options)</p><ul><li>options.$el （模板编译 traversal）</li><li>options.data（数据绑定：Object.define，Proxy）</li><li>options.methods（添加function属性到this）</li></ul></li><li><p>2、渲染和更新</p><ul><li>首次渲染时，会进行依赖收集</li><li>之后数据有变化时，触发Proxy中set的依赖方法</li><li>调用依赖方法后，Dom更新</li></ul></li><li><p>3、vdom（可通过snabbdom学习vdom机制）</p><ul><li>数据变化后触发更新时，出于性能考虑，vue不是直接更新真正的Dom，而是会通过vdom。</li><li>首先，用js模拟DOM结构</li><li>然后，计算出最小的变更</li><li>最后，更新DOM</li><li>具体来说，就是： <ul><li>只进行同级比较，不跨级比较</li><li>优先保留相同节点</li><li>其次移动节点</li><li>最后删除和重建节点</li></ul></li></ul></li></ul><h3 id="react-fiber-能否用于-vue" tabindex="-1">React Fiber 能否用于 Vue？ <a class="header-anchor" href="#react-fiber-能否用于-vue" aria-label="Permalink to &quot;React Fiber 能否用于 Vue？&quot;">​</a></h3><p>最早Vue3的提案其实是包含时间切片方案的，最后废弃的主要原因，是时间切片解决的的问题，Vue3基本碰不到</p><ol><li>Vue3把虚拟Dom控制在组件级别，组件之间使用响应式，这就让Vue3的虚拟Dom不会过于庞大</li><li>Vue3虚拟Dom的静态标记和自动缓存功能，让静态的节点和属性可以直接绕过Diff逻辑，也大大减少了虚拟Dom的Diff事件</li><li>时间切片也会带来额外的系统复杂性</li></ol><p>所以引入时间切片对于Vue3来说投入产出比不太理想，在后来的讨论中，Vue3的时间切片方案就被废弃了</p><h2 id="六、vue的ui框架对比" tabindex="-1">六、Vue的UI框架对比 <a class="header-anchor" href="#六、vue的ui框架对比" aria-label="Permalink to &quot;六、Vue的UI框架对比&quot;">​</a></h2><p>移动端：</p><ul><li>mint-ui</li><li>vant</li><li>vux</li></ul><p>pc端：</p><ul><li>element-ui</li><li>ant design vue</li><li>iview</li><li>heyui</li></ul><h2 id="七、新趋势" tabindex="-1">七、新趋势 <a class="header-anchor" href="#七、新趋势" aria-label="Permalink to &quot;七、新趋势&quot;">​</a></h2><ul><li>Vue3.0 <a href="https://juejin.cn/post/6847902222743765005" target="_blank" rel="noreferrer">变化</a><ul><li>首先是源码优化，vue.js框架本身的优化，目的是让代码更易于开发和维护（使用Typescript）</li><li>性能优化（Object.define =&gt; proxy）</li><li>优化逻辑组织（提供compsositon api）</li></ul></li><li>TypeScript</li><li>Vite</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><p><a href="https://juejin.cn/post/6870374238760894472" target="_blank" rel="noreferrer">vue问答</a></p></li><li><p><a href="https://www.bilibili.com/s/video/BV1XV411U7NU" target="_blank" rel="noreferrer">ToyVue by Winter</a></p></li><li><p><a href="https://juejin.cn/post/6850037277675454478" target="_blank" rel="noreferrer">史上最强vue总结---面试开发全靠它了</a></p></li><li><p><a href="https://www.vuemastery.com/courses/vue3-deep-dive-with-evan-you/" target="_blank" rel="noreferrer">mini-vue</a></p></li><li><p><a href="https://juejin.cn/post/6911897255087702030" target="_blank" rel="noreferrer">[Vue官方教程笔记]- 尤雨溪手写mini-vue</a></p></li><li><p><a href="https://juejin.cn/book/6844733705089449991" target="_blank" rel="noreferrer">剖析 Vue.js 内部运行机制</a></p></li></ul>`,79))])}const g=e(p,[["render",r]]);export{E as __pageData,g as default};
