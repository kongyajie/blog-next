import{_ as i,c as e,o as t,ae as a}from"./chunks/framework.Dh1jimFm.js";const f=JSON.parse('{"title":"Vue系列之6-Vue3","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端框架/vue/Vue系列之6-Vue3.md","filePath":"article/前端框架/vue/Vue系列之6-Vue3.md","lastUpdated":1743859882000}'),o={name:"article/前端框架/vue/Vue系列之6-Vue3.md"};function u(r,l,s,n,p,c){return t(),e("div",null,l[0]||(l[0]=[a('<h1 id="vue系列之6-vue3" tabindex="-1">Vue系列之6-Vue3 <a class="header-anchor" href="#vue系列之6-vue3" aria-label="Permalink to &quot;Vue系列之6-Vue3&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>本章主要内容：</p><ul><li>新功能</li><li>原理</li><li>vite</li></ul><h3 id="vue3比vue2有什么优势-重点" tabindex="-1">Vue3比Vue2有什么优势？（重点） <a class="header-anchor" href="#vue3比vue2有什么优势-重点" aria-label="Permalink to &quot;Vue3比Vue2有什么优势？（重点）&quot;">​</a></h3><ul><li><strong>性能更好</strong></li><li>体积更小</li><li><strong>更好的TS支持</strong></li><li><strong>更好的代码组织&amp;逻辑抽离</strong></li><li>更多新功能</li></ul><h3 id="vue3和vue2生命周期有什么区别" tabindex="-1">Vue3和Vue2生命周期有什么区别？ <a class="header-anchor" href="#vue3和vue2生命周期有什么区别" aria-label="Permalink to &quot;Vue3和Vue2生命周期有什么区别？&quot;">​</a></h3><p>Options API声明周期</p><ul><li>beforeDestory =&gt; beforeUnmount</li><li>destoryed =&gt; unmounted</li></ul><h3 id="如何理解composition-api和options-api-重要" tabindex="-1">如何理解Composition API和Options API（重要） <a class="header-anchor" href="#如何理解composition-api和options-api-重要" aria-label="Permalink to &quot;如何理解Composition API和Options API（重要）&quot;">​</a></h3><p>CompositionAPI带来了什么</p><ul><li>更好的代码组织</li><li>更好的逻辑复用</li><li>更好的类型推导</li></ul><p>如何选择</p><ul><li>不建议共用，会引起混乱</li><li>小型项目、业务逻辑简单，用Options API</li><li>中大型项目、逻辑复杂，用Composition API</li></ul><h3 id="如何理解ref-toref和torefs" tabindex="-1">如何理解ref toRef和toRefs <a class="header-anchor" href="#如何理解ref-toref和torefs" aria-label="Permalink to &quot;如何理解ref toRef和toRefs&quot;">​</a></h3><p>ref</p><ul><li>生成值类型的响应式数据</li><li>可用于模板和reactive</li><li>通过.value修改值</li></ul><p>最佳使用方式</p><ul><li><strong>用reactive做对象的响应式，用ref做值类型的响应式</strong></li><li>setup中返回toRefs(state)，或者toRef(state,&#39;xxx&#39;)</li><li>ref的变量命名都用xxxRef</li><li>合成函数返回响应式对象时，使用toRefs</li></ul><p>为何需要ref？</p><ul><li>返回值类型，会丢失响应式</li><li>如在setup、computed、合成函数，都有可能返回值类型</li><li>Vue如不定义ref，用户将自造ref，反而混乱</li></ul><p>为何需要.value?</p><ul><li>ref是一个对象（不丢失响应式），value存储值</li><li>通过.value属性的get和set实现响应式</li><li>用于模板、Reactive时，不需要.value，其他情况都需要</li></ul><p>为何需要toRef和toRefs？</p><ul><li>初衷：不丢失响应式的情况下，把对象数据<strong>分解/解构</strong></li><li>前提：针对的是响应式对象（reative封装的）非普通对象</li><li>注意：<strong>不创造</strong>响应式，而是<strong>延续</strong>响应式</li></ul><blockquote><p>reactive/ref创建响应式，toRef/toRefs延续响应式</p></blockquote><h3 id="vue3升级了哪些重要功能" tabindex="-1">Vue3升级了哪些重要功能 <a class="header-anchor" href="#vue3升级了哪些重要功能" aria-label="Permalink to &quot;Vue3升级了哪些重要功能&quot;">​</a></h3><ul><li>createApp</li><li>emits属性</li><li>生命周期</li><li>多事件</li><li>Fragment</li><li>移除.sync</li><li>异步组件写法</li><li>移除filter</li><li>Teleport</li><li>Supense</li><li>Composition API</li></ul><h3 id="composition-api-实现逻辑复用" tabindex="-1">Composition API 实现逻辑复用 <a class="header-anchor" href="#composition-api-实现逻辑复用" aria-label="Permalink to &quot;Composition API 实现逻辑复用&quot;">​</a></h3><ul><li>抽离逻辑代码到一个函数</li><li>函数命名约定为 useXxxx 格式（React Hooks也是）</li><li>在 setup 中引用 useXxxx 函数</li></ul><h3 id="vue3如何实现响应式" tabindex="-1">Vue3如何实现响应式 <a class="header-anchor" href="#vue3如何实现响应式" aria-label="Permalink to &quot;Vue3如何实现响应式&quot;">​</a></h3><ul><li>回顾vue2.x的Object.defineProperty</li><li>学习Proxy语法</li><li>Vue3如何用Proxy实现响应式</li></ul><p>Object.definePropery的缺点：</p><ul><li>深度监听需要一次性递归</li><li>无法监听新增属性/删除属性（vue.set Vue.delete)</li><li>无法原生监听数组，需要特殊处理</li></ul><p>Proxy实现响应式</p><ul><li>基本使用</li><li>Reflect</li><li>实现响应式</li></ul><p>Reflect作用</p><ul><li>和Proxy能力一一对应</li><li>规范化、标准化、函数化</li><li>代替Object上的工具函数（防止Object大而全，会更纯净）</li></ul><p>Vue3用Proxy实现响应式</p><ul><li>深度监听，性能更好</li><li>可监听新增/删除属性</li><li>可监听数组变化</li><li>Proxy无法兼容所有浏览器，无法polyfill</li></ul><h3 id="watch和watcheffect的区别" tabindex="-1">watch和watchEffect的区别 <a class="header-anchor" href="#watch和watcheffect的区别" aria-label="Permalink to &quot;watch和watchEffect的区别&quot;">​</a></h3><ul><li>两者都可监听data属性变化</li><li>watch需要明确监听哪个属性</li><li>watchEffect会根据其中的属性，自动监听其变化</li></ul><h3 id="setup中如何获取组件实例" tabindex="-1">setup中如何获取组件实例 <a class="header-anchor" href="#setup中如何获取组件实例" aria-label="Permalink to &quot;setup中如何获取组件实例&quot;">​</a></h3><ul><li>在setup和其他composition API中没有this</li><li>可通过getCurrentInstance获取当前实例</li><li>若使用Options API可正常获取this</li></ul><h3 id="vue3为什么比vue2快-重要" tabindex="-1">Vue3为什么比Vue2快（重要） <a class="header-anchor" href="#vue3为什么比vue2快-重要" aria-label="Permalink to &quot;Vue3为什么比Vue2快（重要）&quot;">​</a></h3><ul><li>Proxy响应式</li><li>PatchFlag 静态比较</li><li>hoistStatic 静态提升</li><li>CacheHandler 缓存事件</li><li>SSR优化</li><li>Tree-Shaking优化</li></ul><p>PatchFlag</p><ul><li>编译模板时，动态节点做标记</li><li>标记，分为不同的类型，如Text、Props</li><li>diff算法时，可以区分静态节点，以及不同类型的动态节点</li></ul><p>hoistStatic</p><ul><li>将静态节点的定义，提升到父作用域，缓存起来</li><li>多个相邻的静态节点，会被合并起来</li><li>典型的拿空间换时间的优化策略</li></ul><p>SSR优化</p><ul><li>静态节点输出，绕过Vdom</li><li>动态节点，还是需要动态渲染</li></ul><p>Vite为什么这么快</p><ul><li>开发环境下使用ES6 Module，无需打包——非常快</li><li>生产环境使用rollup，并不会快很多</li><li>ES6 Module兼容性目前大部分浏览器都支持，未来几年很可能生产环境也可以使用</li></ul><h3 id="composition-api和react-hooks对比" tabindex="-1">Composition API和React Hooks对比 <a class="header-anchor" href="#composition-api和react-hooks对比" aria-label="Permalink to &quot;Composition API和React Hooks对比&quot;">​</a></h3><ul><li>前者setup只会被调用一次，而后者函数会被多次调用</li><li>前者无需useMemo、useCallback，因为setup只调用一次</li><li>前者无需顾虑调用顺序，而后者需要保证hooks的顺序一致</li><li>前者reactive和ref比后者useState，要难理解</li></ul>',56)]))}const d=i(o,[["render",u]]);export{f as __pageData,d as default};
