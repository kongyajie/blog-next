import{_ as a,c as l,o as e,ae as s}from"./chunks/framework.Dh1jimFm.js";const k=JSON.parse('{"title":"Week2 脚手架架构设计和框架搭建","description":"","frontmatter":{},"headers":[],"relativePath":"article/架构师课程/week2-笔记.md","filePath":"article/架构师课程/week2-笔记.md","lastUpdated":1743859882000}'),n={name:"article/架构师课程/week2-笔记.md"};function t(o,i,r,h,p,d){return e(),l("div",null,i[0]||(i[0]=[s(`<p>[TOC]</p><h1 id="week2-脚手架架构设计和框架搭建" tabindex="-1">Week2 脚手架架构设计和框架搭建 <a class="header-anchor" href="#week2-脚手架架构设计和框架搭建" aria-label="Permalink to &quot;Week2 脚手架架构设计和框架搭建&quot;">​</a></h1><p><a href="https://www.imooc.com/wiki/weban/week1a.html" target="_blank" rel="noreferrer">前端架构师-电子书</a></p><h2 id="本周导学" tabindex="-1">本周导学 <a class="header-anchor" href="#本周导学" aria-label="Permalink to &quot;本周导学&quot;">​</a></h2><h3 id="将收获什么" tabindex="-1">将收获什么 <a class="header-anchor" href="#将收获什么" aria-label="Permalink to &quot;将收获什么&quot;">​</a></h3><ul><li>脚手架的实现原理</li><li>Lerna的常见用法</li><li>架构设计技巧和架构图绘制方法</li></ul><h3 id="主要内容" tabindex="-1">主要内容 <a class="header-anchor" href="#主要内容" aria-label="Permalink to &quot;主要内容&quot;">​</a></h3><ul><li>学习如何以架构师的角度思考基础架构问题</li><li>多Package项目管理痛点和解决方案，基于Lerna脚手架框架搭建</li><li>imooc-cli脚手架需求分析和架构设计、架构设计图</li></ul><h3 id="附赠内容" tabindex="-1">附赠内容 <a class="header-anchor" href="#附赠内容" aria-label="Permalink to &quot;附赠内容&quot;">​</a></h3><ul><li>脚手架调试技巧</li><li>Lerna源码分析（Node的module模块分析、yargs使用方法、剖析Lerna架构设计）</li></ul><h3 id="关键词" tabindex="-1">关键词 <a class="header-anchor" href="#关键词" aria-label="Permalink to &quot;关键词&quot;">​</a></h3><ul><li>脚手架 - 掌握脚手架原理和开发全流程</li><li>Lerna - 解决多Package项目管理痛点</li><li>架构设计 - 学习大厂基础基础架构设计思路</li></ul><h3 id="学习方法" tabindex="-1">学习方法 <a class="header-anchor" href="#学习方法" aria-label="Permalink to &quot;学习方法&quot;">​</a></h3><ul><li><strong>架构三部曲：掌握原理 -&gt; 独立思考 -&gt; 总结反思</strong></li><li>深度剖析优秀开源项目，由表及里，由浅入深</li><li><strong>视角切换：多切换到架构师视角，从全局思考问题</strong></li></ul><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>整体难度不高，不用担心学不会，坚持打卡写心得</li><li>优秀的程序猿不止能够实现功能，更多读懂别人的代码，读懂别人的想法</li><li>从知名的开源项目中汲取养分，为我所用，助我成长</li></ul><h3 id="前端脚手架imooc-cli核心功能演示" tabindex="-1">前端脚手架imooc-cli核心功能演示 <a class="header-anchor" href="#前端脚手架imooc-cli核心功能演示" aria-label="Permalink to &quot;前端脚手架imooc-cli核心功能演示&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @imooc-cli/core</span></span></code></pre></div><h2 id="_1、站在前端研发的视角-分析开发脚手架的必要性" tabindex="-1">1、站在前端研发的视角，分析开发脚手架的必要性 <a class="header-anchor" href="#_1、站在前端研发的视角-分析开发脚手架的必要性" aria-label="Permalink to &quot;1、站在前端研发的视角，分析开发脚手架的必要性&quot;">​</a></h2><h3 id="研发效能" tabindex="-1">研发效能 <a class="header-anchor" href="#研发效能" aria-label="Permalink to &quot;研发效能&quot;">​</a></h3><p><strong>开发脚手架的核心目标是：提升前端研发效能</strong></p><p>大厂研发架构图：</p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt=""></p><h3 id="脚手架核心价值" tabindex="-1">脚手架核心价值 <a class="header-anchor" href="#脚手架核心价值" aria-label="Permalink to &quot;脚手架核心价值&quot;">​</a></h3><p>将研发过程：</p><ul><li>自动化：项目重复代码拷贝/git操作/发布上线操作</li><li>标准化：项目创建/git flow/发布流程/回滚流程</li><li>数据化：研发过程系统化、数据化，使得研发过程可量化</li></ul><h3 id="和自动化构建工具区别" tabindex="-1">和自动化构建工具区别 <a class="header-anchor" href="#和自动化构建工具区别" aria-label="Permalink to &quot;和自动化构建工具区别&quot;">​</a></h3><blockquote><p>问题：jenkins、travis等自动化构建工具已经比较成熟了，为什么还需要自研脚手架？</p></blockquote><ul><li>不满足需求：jenkins、travis通常在git hooks中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动化、本地git操作自动化等</li><li>定制复杂：jenkins、travis定制过程需要开发插件，其过程较为复杂，需要使用Java语言，对前端同学不够友好</li></ul><h2 id="_2、从使用角度理解什么是脚手架" tabindex="-1">2、从使用角度理解什么是脚手架？ <a class="header-anchor" href="#_2、从使用角度理解什么是脚手架" aria-label="Permalink to &quot;2、从使用角度理解什么是脚手架？&quot;">​</a></h2><h3 id="脚手架简介" tabindex="-1">脚手架简介 <a class="header-anchor" href="#脚手架简介" aria-label="Permalink to &quot;脚手架简介&quot;">​</a></h3><blockquote><p>脚手架本质是一个操作系统的客户端，它通过命令行执行。</p></blockquote><p>比如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> vue-test-app</span></span></code></pre></div><p>上面这条命令由 3 个部分组成：</p><ul><li>主命令: vue</li><li>command: create</li><li>command 的 param: vue-test-app</li></ul><p>它表示创建一个 vue 项目，项目的名称为 vue-test-app，以上是最一个较为简单的脚手架命令。</p><h3 id="脚手架的执行原理" tabindex="-1">脚手架的执行原理 <a class="header-anchor" href="#脚手架的执行原理" aria-label="Permalink to &quot;脚手架的执行原理&quot;">​</a></h3><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.jpeg" alt=""></p><p>脚手架的执行原理如下：</p><ul><li>在终端输入 vue create vue-test-app</li><li>终端解析出 vue 命令</li><li>终端在环境变量中找到 vue 命令</li><li>终端根据 vue 命令链接到实际文件 vue.js</li><li>终端利用 node 执行 vue.js</li><li>vue.js 解析 command / options</li><li>vue.js 执行 command</li><li>执行完毕，退出执行</li></ul><h2 id="_3、脚手架的实现原理" tabindex="-1">3、脚手架的实现原理 <a class="header-anchor" href="#_3、脚手架的实现原理" aria-label="Permalink to &quot;3、脚手架的实现原理&quot;">​</a></h2><p>问题：</p><ol><li>全局安装 <code>@vue/cli</code> 时发生了什么？ <ul><li>将 <code>@vue/cli</code> 安装到 <code>node/lib/node_module</code> 中</li><li>创建软链 <code>vue</code> 链接到 <code>@vue/cli</code> 项目中的 <code>bin/vue.js</code> （在终端中使用 <code>which vue</code> 查看）</li></ul></li><li>在终端执行 <code>vue create vue-test-app</code> 时发生了什么？ <ul><li>终端解析出 vue 命令</li><li>终端在环境变量中找到 vue 命令</li><li>终端根据 vue 命令链接到实际文件 vue.js</li><li>终端利用 node 执行 vue.js</li></ul></li></ol><p>脚手架执行的全过程：</p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6.png" alt=""></p><h2 id="_4、脚手架的开发流程" tabindex="-1">4、脚手架的开发流程 <a class="header-anchor" href="#_4、脚手架的开发流程" aria-label="Permalink to &quot;4、脚手架的开发流程&quot;">​</a></h2><h3 id="开发流程" tabindex="-1">开发流程 <a class="header-anchor" href="#开发流程" aria-label="Permalink to &quot;开发流程&quot;">​</a></h3><ol><li>创建项目，并初始化 npm</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jay-cli-demo</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 创建项目目录</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jay-cli-demo</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 进入目录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> init</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -y</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 初始化npm</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">code</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 使用vscode打开项目</span></span></code></pre></div><ol start="2"><li>新建bin目录，并在目录下新增index.js文件，做为脚手架入口文件（注意要再最上方添加一行代码，用于查找当前使用环境下的node）：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/usr/bin/env node</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;welcome to jay-cli-demo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ol start="3"><li>配置 package.json，添加 bin 属性</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;jay-cli-demo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;description&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;bin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;jay-test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bin/index.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;main&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Error: no test specified</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &amp;&amp; exit 1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [],</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;author&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;license&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ISC&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li>将脚手架发布到 npm（发布过程中遇到问题请请参考网上的发布文章）</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> publish</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 发布到npm</span></span></code></pre></div><blockquote><p>注意，因为npm不允许出现重复的包名，因此需要将上一步中 package.json 中的 name 从 <code>jay-cli-demo</code> 改为 <a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">npmjs.com</a> 上未被占用的名字。</p></blockquote><h3 id="使用流程" tabindex="-1">使用流程 <a class="header-anchor" href="#使用流程" aria-label="Permalink to &quot;使用流程&quot;">​</a></h3><ol><li>安装脚手架</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> jay-cli-demo</span></span></code></pre></div><ol start="2"><li>使用脚手架</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jay-test</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># welcome to jay-cli-demo</span></span></code></pre></div><h3 id="开发难点" tabindex="-1">开发难点 <a class="header-anchor" href="#开发难点" aria-label="Permalink to &quot;开发难点&quot;">​</a></h3><ul><li>分包：将复杂的系统拆分成若干个模块</li><li>命令注册</li><li>参数解析</li></ul><p>还有很多，比如：</p><ul><li>命令行交互</li><li>日志打印</li><li>命令行文字变色</li><li>网络通信：HTTP/WebSocket</li><li>文件处理</li></ul><h3 id="本地调试" tabindex="-1">本地调试 <a class="header-anchor" href="#本地调试" aria-label="Permalink to &quot;本地调试&quot;">​</a></h3><p>以 <code>jay-cli-test</code> 为例</p><p><strong>方法一：在项目目录下使用 <code>npm link</code>：</strong></p><ul><li>在 <code>.nvm/versions/node/v14.15.4/lib/node_modules</code> 目录中，会创建一个 <code>jay-cli-test</code> 软链,链接到项目目录</li><li>运行 <code>jay-cli-test</code> 即运行项目目录中 <code>package.json</code> 中的 <code>bin</code> 配置命令</li></ul><p><strong>方法二：在项目目录的父级下使用 <code>npm i jay-cli-test -g</code></strong></p><ul><li>npm 会默认给我们创建一个软链，效果同上</li><li>如果希望删除这个软链，使用npm线上版本，可以在这个项目目录的非父级目录下，再来一次 <code>npm i jay-cli-test -g</code> 即可。</li></ul><p>分包情况：以 <code>jay-cli-test-lib</code> 为例。</p><h3 id="本地link标准流程" tabindex="-1">本地link标准流程 <a class="header-anchor" href="#本地link标准流程" aria-label="Permalink to &quot;本地link标准流程&quot;">​</a></h3><p>链接本地脚手架：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-cli-dir</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link</span></span></code></pre></div><p>链接本地库文件：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-lib-dir</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-cli-dir</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-lib</span></span></code></pre></div><p>取消链接本地库文件：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除主项目对库文件的软链</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-cli-dir</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unlink</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-lib</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除库文件的本地软链</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-lib-dir</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unlink</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除主项目的软链</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-cli-dir</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> unlink</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 当遇到库文件link不存在的情况时，可尝试下面的方式解决</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -rf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> your-lib</span></span></code></pre></div><p>理解 <code>npm link</code>：</p><ul><li><code>npm link your-lib</code>：将当前项目中 <code>node_modules</code> 下指定的库文件链接到 <code>node</code> 全局 <code>node_modules</code> 下的库文件</li><li><code>npm link</code>：将当前项目链接到 <code>node</code> 全局 <code>node_modules</code> 中作为一个库文件，并解析 <code>bin</code> 配置创建可执行文件</li></ul><p>理解 <code>npm unlink</code>：</p><ul><li><code>npm unlink</code>：将当前项目从 <code>node</code> 全局 <code>node_modules</code> 中移除</li><li><code>npm unlink your-lib</code>：将当前项目中的库文件依赖移除</li></ul><p>注意，使用 <code>nvm</code> 管理 npm 后情况稍有不同：</p><ul><li>全局 <code>node_modules</code> 目录为：<code>/Users/aaron/.nvm/versions/node/v14.15.4/lib/node_modules</code></li><li>bin 目录为：<code>/Users/aaron/.nvm/versions/node/v14.15.4/bin</code></li><li>bin 目录中的指令指向全局 <code>node_modules</code> 中的依赖</li></ul><h3 id="产出测试脚手架-—-jay-test-cli" tabindex="-1">产出测试脚手架 — jay-test-cli <a class="header-anchor" href="#产出测试脚手架-—-jay-test-cli" aria-label="Permalink to &quot;产出测试脚手架 — jay-test-cli&quot;">​</a></h3><p><a href="https://gitee.com/AaronKong/jay-test" target="_blank" rel="noreferrer">代码地址</a></p><p>npm包：</p><ul><li><a href="https://www.npmjs.com/package/jay-test-cli" target="_blank" rel="noreferrer">jay-test-cli</a></li><li><a href="https://www.npmjs.com/package/jay-test-cli-lib" target="_blank" rel="noreferrer">jay-test-cli-lib</a></li></ul><p>使用方式：</p><ol><li>安装： <code>npm i jay-test-cli -g</code></li><li>运行： <code>jay-test-cli -V</code></li></ol><h2 id="_5、lerna简介" tabindex="-1">5、Lerna简介 <a class="header-anchor" href="#_5、lerna简介" aria-label="Permalink to &quot;5、Lerna简介&quot;">​</a></h2><h3 id="原生脚手架开发痛点分析" tabindex="-1">原生脚手架开发痛点分析 <a class="header-anchor" href="#原生脚手架开发痛点分析" aria-label="Permalink to &quot;原生脚手架开发痛点分析&quot;">​</a></h3><ul><li><p>痛点一：重复操作</p><ul><li>多 Package 本地 link</li><li>多 Package 依赖安装</li><li>多 Package 单元测试</li><li>多 Package 代码提交</li><li>多 Package 代码发布</li></ul></li><li><p>痛点二：版本一致性</p><ul><li>发布时版本一致性</li><li>发布后相互依赖版本升级</li></ul></li></ul><blockquote><p>package 越多，管理复杂度越高</p></blockquote><h3 id="lerna简介" tabindex="-1">Lerna简介 <a class="header-anchor" href="#lerna简介" aria-label="Permalink to &quot;Lerna简介&quot;">​</a></h3><blockquote><p>Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.</p><p><strong>Lerna 是一个优化基于 git+npm 的多 package 项目的管理工具</strong></p></blockquote><p><strong>优势</strong></p><ul><li>大幅减少重复操作</li><li>提升操作的标准化</li></ul><blockquote><p>Lerna 是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。</p></blockquote><p><strong>官网</strong><a href="https://lerna.js.org/" target="_blank" rel="noreferrer">https://lerna.js.org/</a></p><p><strong>案例</strong> 使用 Lerna 管理的大型项目：</p><ul><li>babel: <a href="https://github.com/babel/babel" target="_blank" rel="noreferrer">https://github.com/babel/babel</a></li><li>vue-cli: <a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noreferrer">https://github.com/vuejs/vue-cli</a></li><li><s>create-react-app: <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noreferrer">https://github.com/facebook/create-react-app</a></s></li></ul><p><strong>lerna 开发脚手架流程（划重点）</strong></p><p><img src="https://oss-1252175178.cos.ap-shanghai.myqcloud.com/%E6%85%95%E8%AF%BE%E7%BD%91%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AF%BE%E7%A8%8B/lerna%20%E5%BC%80%E5%8F%91%E8%84%9A%E6%89%8B%E6%9E%B6%E6%B5%81%E7%A8%8B.png" alt=""></p><h3 id="lerna-命令介绍" tabindex="-1">Lerna 命令介绍 <a class="header-anchor" href="#lerna-命令介绍" aria-label="Permalink to &quot;Lerna 命令介绍&quot;">​</a></h3><p>参考<a href="https://github.com/lerna/lerna" target="_blank" rel="noreferrer">官网</a></p><ul><li>lerna init <ul><li>描述：初始化 lerna 项目，添加 <code>lerna.json</code> 和 <code>packages</code> 目录</li><li>示例：<code>lerna init</code></li></ul></li><li>lerna create <ul><li>描述：创建packages包</li><li>示例：<code>lerna create core</code></li></ul></li><li>lerna add <ul><li>描述：对所有packages包，安装依赖，也可单独给某个packages包安装依赖</li><li>示例：<code>lerna add lodash </code> <code>lerna add lodash packages/core/</code></li></ul></li><li>lerna link <ul><li>描述：自动添加packages包之间的软链（如果有依赖关系的话）</li><li>示例：<code>lerna link</code></li></ul></li><li>lerna clean <ul><li>描述：对所有packages包，删除其中的 <code>node_modules</code></li><li>示例：<code>lerna clean</code></li></ul></li><li>lerna bootstrap <ul><li>描述：给所有packages包，安装依赖，等同于cd 到每个包中，执行 <code>npm i</code></li><li>示例：<code>lerna bootstrap</code></li></ul></li><li>lerna exec <ul><li>描述：对所有packages包，执行shell脚本，也可单独对某个包执行</li><li>示例： <ul><li><code>lerna exec -- rm -rf node_modules</code></li><li><code>lerna exec --scope @jay-cli-dev/core -- rm -rf node_modules</code></li></ul></li></ul></li><li>lerna run <ul><li>描述：对所有packages包，运行某条命令</li><li>示例： <ul><li><code>lerna run test </code></li><li><code>lerna run --scope @jay-cli-dev/utils test</code></li></ul></li></ul></li><li>lerna version</li><li>lerna diff</li><li>lerna publish</li></ul><h2 id="_6、lerna源码分析" tabindex="-1">6、Lerna源码分析 <a class="header-anchor" href="#_6、lerna源码分析" aria-label="Permalink to &quot;6、Lerna源码分析&quot;">​</a></h2><h3 id="【讨论题】谈一谈-node和web的事件循环-eventloop-机制的异同" tabindex="-1">【讨论题】谈一谈 Node和Web的事件循环（EventLoop）机制的异同 <a class="header-anchor" href="#【讨论题】谈一谈-node和web的事件循环-eventloop-机制的异同" aria-label="Permalink to &quot;【讨论题】谈一谈 Node和Web的事件循环（EventLoop）机制的异同&quot;">​</a></h3><ul><li>运行机制基本类似： <ul><li>Web 的宏任务如 <code>setTimeout</code> 、<code>Ajax</code> ，主要交由对应的 Web API 处理，然后回调函数交由 V8 引擎处理</li><li>Node 的宏任务如 <code>setTimeout</code>、<code>fs.readFile</code> 等 Node API 则主要是由跨平台异步IO库 <code>libuv</code> 处理，然后回调函数交由 V8 引擎处理</li></ul></li><li>Node 中多了 process.nextTick 和 setImmediate，两者都提供的是异步能力 <ul><li>process.nextTick 是微任务</li><li>setImmediate 是宏任务</li></ul></li><li>Node.js的Event Loop跟浏览器的Event Loop不一样，他是分阶段的</li><li><code>setImmediate</code> 和 <code>setTimeout(fn, 0)</code> 哪个回调先执行，需要看他们本身在哪个阶段注册的，如果在定时器回调或者I/O回调里面，<code>setImmediate</code> 肯定先执行。如果在最外层或者 <code>setImmediate</code> 回调里面，哪个先执行取决于当时机器状况。</li><li><code>process.nextTick</code> 不在Event Loop的任何阶段，他是一个特殊API，他会立即执行，然后才会继续执行Event Loop</li></ul><p>参考资料：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noreferrer">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://juejin.cn/post/6844904100195205133" target="_blank" rel="noreferrer">setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop</a></li><li><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noreferrer">Node.js 事件循环，定时器和 process.nextTick()</a></li><li><a href="https://zhuanlan.zhihu.com/p/80458653" target="_blank" rel="noreferrer">正确理解 Node.js 的 Event loop</a></li></ul><h2 id="_7、基于lerna重新设计jl" tabindex="-1">7、基于Lerna重新设计JL <a class="header-anchor" href="#_7、基于lerna重新设计jl" aria-label="Permalink to &quot;7、基于Lerna重新设计JL&quot;">​</a></h2><p>JL中新增：</p><ul><li>熟悉Yargs脚手架开发框架</li><li>熟悉多Package管理工具Lerna的使用方法和实现原理</li><li>深入理解Node.js模块路径解析流程</li></ul><h3 id="yargs" tabindex="-1">yargs <a class="header-anchor" href="#yargs" aria-label="Permalink to &quot;yargs&quot;">​</a></h3><ul><li>脚手架构成 <ul><li>bin：package.json中配置bin属性，npm link 本地安装</li><li>command：命令</li><li>options：参数（boolean/string/number）</li><li>文件顶部增加 <code>#!/usr/bin/env node</code></li></ul></li><li>脚手架-<strong>初始化</strong>流程 <ul><li>构造函数：Yargs()</li><li>常用方法： <ul><li><strong>Yargs.options</strong></li><li>Yargs.option</li><li><strong>Yargs.group</strong></li><li>Yargs.demandCommand</li><li>Yargs.recommendCommands</li><li>Yargs.strict</li><li><strong>Yargs.fail</strong></li><li>Yargs.alias</li><li>Yargs.wrap</li><li>Yargs.epilogue</li></ul></li></ul></li><li>脚手架-<strong>参数解析</strong>方法 <ul><li><strong>hideBin</strong>(process.argv) / Yargs.argv</li><li><strong>Yargs.parse(argv, options)</strong></li></ul></li><li>脚手架-<strong>命令注册</strong>方法 <ul><li><strong>Yargs.command(command, describe, builder, handler)</strong></li><li><strong>Yargs.command({ command, describe, builder, handler })</strong></li></ul></li></ul><h3 id="lerna" tabindex="-1">Lerna <a class="header-anchor" href="#lerna" aria-label="Permalink to &quot;Lerna&quot;">​</a></h3><ul><li><p>Lerna 是基于 git+npm 的多package项目管理工具，提供了一系列的命令来降低多包项目的管理成本，如：</p><ul><li>lerna init 初始化</li><li>lerna create 创建包</li><li>lerna add 安装依赖</li><li>lerna exec 执行脚本</li><li>lerna run 执行命令</li></ul></li><li><p>实现原理</p><ul><li>通过 import-local 优先调用本地 lerna 命令</li><li>通过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数</li><li>lerna 命令注册时需要传入 builder 和 handler 两个方法，builder 方法用于注册命令专属的 options，handler 用来处理命令的业务逻辑</li><li><strong>lerna 通过配置 npm 本地依赖的方式来进行本地开发</strong>，具体写法是在 package.json 的依赖中写入：<code>file:your-local-module-path</code> ，在 lerna publish 时会自动将该路径替换</li></ul></li></ul><h3 id="node-js-模块路径解析流程" tabindex="-1">Node.js 模块路径解析流程 <a class="header-anchor" href="#node-js-模块路径解析流程" aria-label="Permalink to &quot;Node.js 模块路径解析流程&quot;">​</a></h3><ul><li>Node.js 项目模块路径解析是通过 <code>require.resolve</code> 方法来实现的</li><li><code>require.resolve</code> 就是通过 <code>Module._resolveFileName</code> 方法实现的</li><li><code>require.resolve</code> 实现原理： <ul><li><code>Module._resolveFileName</code>方法核心流程有 3 点： <ul><li>判断是否为内置模块</li><li>通过 <code>Module._resolveLookupPaths</code> 方法生成 node_modules 可能存在的路径</li><li>通过 <code>Module._findPath</code> 查询模块的真实路径</li></ul></li><li><code>Module._findPath</code> 核心流程有 4 点： <ul><li>查询缓存（将 request 和 paths 通过 <code>\\x00</code> 合并成 cacheKey）</li><li>遍历 paths，将 path 与 request 组成文件路径 basePath</li><li>如果 basePath 存在则调用 <code>fs.realPathSync</code> 获取文件真实路径</li><li>将文件真实路径缓存到 <code>Module._pathCache</code>（key 就是前面生成的 cacheKey）</li></ul></li><li><code>fs.realPathSync</code> 核心流程有 3 点： <ul><li>查询缓存（缓存的 key 为 p，即 <code>Module._findPath</code> 中生成的文件路径）</li><li>从左往右遍历路径字符串，查询到 <code>/</code> 时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路径 p，然后继续往后遍历，这里有 1 个细节需要特别注意： <ul><li>遍历过程中生成的子路径 base 会缓存在 knownHard 和 cache 中，避免重复查询</li></ul></li><li>遍历完成得到模块对应的真实路径，此时会将原始路径 original 作为 key，真实路径作为 value，保存到缓存中</li></ul></li></ul></li><li><code>require.resolve.paths</code> 等价于 <code>Module._resolveLookupPaths</code>，该方法用于获取所有 node_modules 可能存在的路径</li><li><code>require.resolve.paths</code> 实现原理： <ul><li>如果路径为 <code>/</code>（根目录），直接返回 <code>[&#39;/node_modules&#39;]</code></li><li>否则，将路径字符串从后往前遍历，查询到 <code>/</code> 时，拆分路径，在后面加上 node_modules，并传入一个 paths 数组，直至查询不到 <code>/</code> 后返回 paths 数组</li></ul></li></ul><h2 id="本周作业" tabindex="-1">本周作业 <a class="header-anchor" href="#本周作业" aria-label="Permalink to &quot;本周作业&quot;">​</a></h2><ul><li>标准： <ul><li><p>理解脚手架的实现原理</p></li><li><p>基于 <code>Lerna</code> 搭建自己的脚手架并发布到npm（功能不限）</p></li></ul></li><li>进阶： <ul><li>理解 <code>Yargs</code> 常用API和开发流程</li><li>理解 <code>Lerna</code> 实现原理</li><li>理解 <code>import-local</code> 实现原理，理解 <code>require.resolve</code> 实现原理</li></ul></li><li>本周打卡： <ul><li>作业地址：<a href="https://github.com/imooc-lego/students-learn-task" target="_blank" rel="noreferrer">https://github.com/imooc-lego/students-learn-task</a></li><li>学员学习任务，作业、打卡、分享，请看 <a href="https://homework.imooc-lego.com" target="_blank" rel="noreferrer">homework.imooc-lego.com</a></li></ul></li></ul>`,125)]))}const u=a(n,[["render",t]]);export{k as __pageData,u as default};
