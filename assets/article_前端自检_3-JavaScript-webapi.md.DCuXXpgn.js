import{_ as i,c as a,o as e,ae as t}from"./chunks/framework.Dh1jimFm.js";const h=JSON.parse('{"title":"JavaScript-webapi","description":"","frontmatter":{},"headers":[],"relativePath":"article/前端自检/3-JavaScript-webapi.md","filePath":"article/前端自检/3-JavaScript-webapi.md","lastUpdated":1743859882000}'),r={name:"article/前端自检/3-JavaScript-webapi.md"};function o(u,l,n,c,d,s){return e(),a("div",null,l[0]||(l[0]=[t('<h1 id="javascript-webapi" tabindex="-1">JavaScript-webapi <a class="header-anchor" href="#javascript-webapi" aria-label="Permalink to &quot;JavaScript-webapi&quot;">​</a></h1><h3 id="考点总结" tabindex="-1">考点总结 <a class="header-anchor" href="#考点总结" aria-label="Permalink to &quot;考点总结&quot;">​</a></h3><ul><li>eventloop</li><li>DOM事件和event loop</li><li>Promise进阶</li><li>async/await</li></ul><h3 id="dom" tabindex="-1">DOM <a class="header-anchor" href="#dom" aria-label="Permalink to &quot;DOM&quot;">​</a></h3><ul><li>DOM 本质：HTML解析出的一棵树</li><li>DOM 节点操作 <ul><li>获取DOM节点</li><li>property和attribute <ul><li>property：修改JS对象属性，不会体现再HTML结构中</li><li>attribute：修改HTML属性，会改变HTML结构（标签结构）</li><li>两者都有可能引起DOM重新渲染</li><li>建议：尽量用 property 操作，因为property可能会在JS机制中，避免一些不必要的DOM渲染；但是attribute是修改HTML结构，一定会引起DOM结构的重新渲染，而DOM重新渲染是比较耗费性能的</li></ul></li></ul></li><li>DOM 结构操作 <ul><li>新增/插入节点 <ul><li>appendChild</li></ul></li><li>获取子元素列表，获取父元素 <ul><li>childNodes</li><li>parentNode</li><li>nodeName</li><li>nodeType</li></ul></li><li>删除子元素 <ul><li>removeChild</li></ul></li></ul></li><li>DOM操作性能优化 <ul><li>DOM查询做缓存</li><li>将频繁操作改为一次性操作 document.createDocumentFragment()</li></ul></li><li>HTML 页面的生命周期包含三个重要事件 <ul><li><strong>DOMContentLoaded</strong> —— 浏览器已完全加载 HTML，并构建了 DOM 树，但像 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成。</li><li><strong>load</strong> —— 浏览器不仅加载完成了 HTML，还加载完成了所有外部资源：图片，样式等。</li><li><strong>beforeunload</strong>/<strong>unload</strong> —— 当用户正在离开页面时。</li></ul></li></ul><h3 id="bom-browser-object-model" tabindex="-1">BOM（Browser Object Model） <a class="header-anchor" href="#bom-browser-object-model" aria-label="Permalink to &quot;BOM（Browser Object Model）&quot;">​</a></h3><ul><li>navigator <ul><li>userAgent</li></ul></li><li>screen <ul><li>width</li><li>height</li></ul></li><li>location <ul><li>href</li><li>protocol</li><li>hostname</li><li>pathname</li><li>search</li><li>hash</li></ul></li><li>history <ul><li>back()</li><li>forward()</li></ul></li></ul><h3 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h3><ul><li>面试题 <ul><li>写一个通用的事件绑定函数</li><li>描述事件冒泡的流程 <ul><li>基于DOM树形结构</li><li>事件会顺着触发元素向上冒泡</li><li>应用场景：代理</li></ul></li><li>无限下拉的图片列表，如何监听每个图片的点击 <ul><li>事件代理</li><li>用 e.target 获取触发元素</li><li>用 matches 来判断是否是触发元素</li></ul></li></ul></li><li>知识点 <ul><li>事件绑定</li><li>事件冒泡</li><li>事件代理 <ul><li>代码简洁</li><li>减少浏览器内存占用</li><li>但是，不要滥用</li></ul></li></ul></li></ul>',9)]))}const b=i(r,[["render",o]]);export{h as __pageData,b as default};
